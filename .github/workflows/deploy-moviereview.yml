name: Deploy MovieReview Multi-Instance

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:
    inputs:
      deployment_environment:
        description: 'Deployment Environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      instances_to_deploy:
        description: 'Instances to deploy (JSON array format: [{"name":"instance1","port":5010},{"name":"instance2","port":5012}])'
        required: true
        default: '[{"name":"friends","port":5010},{"name":"kids","port":5012},{"name":"demo","port":5015}]'
        type: string

env:
  DOTNET_VERSION: '9.0.x'
  SOLUTION_PATH: './MovieReviewApp.sln'
  PROJECT_PATH: './MovieReviewApp/MovieReviewApp.csproj'
  PUBLISH_OUTPUT: './publish'

jobs:
  parse-instances:
    runs-on: windows-latest
    outputs:
      instances: ${{ steps.parse.outputs.instances }}
    steps:
    - name: Parse instance configuration
      id: parse
      shell: powershell
      run: |
        $instancesInput = '${{ github.event.inputs.instances_to_deploy }}'
        
        # Default instances if not provided
        if ([string]::IsNullOrWhiteSpace($instancesInput)) {
          $instancesInput = '[{"name":"friends","port":5010},{"name":"kids","port":5012},{"name":"demo","port":5015}]'
        }
        
        # Validate JSON
        try {
          $instances = $instancesInput | ConvertFrom-Json
          Write-Host "Parsed instances: $($instances | ConvertTo-Json -Compress)"
          
          # Output for matrix
          "instances=$instancesInput" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        } catch {
          Write-Error "Invalid JSON format for instances"
          exit 1
        }

  build-and-test:
    runs-on: windows-latest
    name: Build and Test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_PATH }}
      
    - name: Build solution
      run: dotnet build ${{ env.SOLUTION_PATH }} --configuration Release --no-restore
      
    - name: Run tests
      run: dotnet test ${{ env.SOLUTION_PATH }} --configuration Release --no-build --verbosity normal
      
    - name: Publish application
      run: dotnet publish ${{ env.PROJECT_PATH }} --configuration Release --output ${{ env.PUBLISH_OUTPUT }} --no-build
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: moviereview-build
        path: ${{ env.PUBLISH_OUTPUT }}
        retention-days: 30

  deploy-to-self-hosted:
    runs-on: self-hosted
    name: Deploy to IIS
    needs: [build-and-test, parse-instances]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment: ${{ github.event.inputs.deployment_environment || 'staging' }}
    
    strategy:
      matrix:
        instance: ${{ fromJson(needs.parse-instances.outputs.instances) }}
      fail-fast: false
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: moviereview-build
        path: ${{ env.PUBLISH_OUTPUT }}
        
    - name: Stop IIS Website and App Pool
      shell: powershell
      run: |
        $instanceName = '${{ matrix.instance.name }}'
        $siteName = "MovieReview_$instanceName"
        $appPoolName = "MovieReview_$instanceName"
        
        Write-Host "Stopping IIS site: $siteName"
        try {
          if (Get-Website -Name $siteName -ErrorAction SilentlyContinue) {
            Stop-Website -Name $siteName
            Write-Host "Website stopped"
          } else {
            Write-Host "Website does not exist"
          }
          
          if (Get-IISAppPool -Name $appPoolName -ErrorAction SilentlyContinue) {
            Stop-WebAppPool -Name $appPoolName
            Write-Host "App pool stopped"
          } else {
            Write-Host "App pool does not exist"
          }
        } catch {
          Write-Host "Warning: Could not stop IIS resources: $_"
        }
        
        # Ensure processes are stopped
        Start-Sleep -Seconds 10
        
    - name: Deploy to IIS Directory
      shell: powershell
      run: |
        $instanceName = '${{ matrix.instance.name }}'
        $deployPath = "C:\inetpub\wwwroot\MovieReview_$instanceName"
        $sourcePath = '${{ env.PUBLISH_OUTPUT }}'
        
        Write-Host "Deploying to: $deployPath"
        Write-Host "From: $sourcePath"
        
        # Create directory if it doesn't exist
        if (-not (Test-Path $deployPath)) {
          New-Item -Path $deployPath -ItemType Directory -Force
          Write-Host "Created deployment directory"
        }
        
        # Create backup
        $backupPath = "${deployPath}.backup.$(Get-Date -Format 'yyyyMMdd-HHmmss')"
        if (Test-Path "$deployPath\MovieReviewApp.dll") {
          Write-Host "Creating backup: $backupPath"
          Copy-Item -Path $deployPath -Destination $backupPath -Recurse -Force
        }
        
        # Copy files
        Write-Host "Copying application files..."
        robocopy $sourcePath $deployPath /MIR /R:3 /W:5 /MT:4 /XD logs instances secrets temp uploads
        $robocopyExitCode = $LASTEXITCODE
        
        if ($robocopyExitCode -ge 8) {
          Write-Error "File copy failed with exit code: $robocopyExitCode"
          exit 1
        } elseif ($robocopyExitCode -eq 0) {
          Write-Host "No files needed to be copied"
        } else {
          Write-Host "Files copied successfully (exit code: $robocopyExitCode)"
        }
        
        # Reset exit code to 0 for PowerShell
        $global:LASTEXITCODE = 0
        
        Write-Host "Application files deployed successfully"
        
    - name: Configure web.config for instance
      shell: powershell
      run: |
        $instanceName = '${{ matrix.instance.name }}'
        $instancePort = '${{ matrix.instance.port }}'
        $deployPath = "C:\inetpub\wwwroot\MovieReview_$instanceName"
        $webConfigPath = Join-Path $deployPath 'web.config'
        
        $webConfig = @"
        <?xml version="1.0" encoding="utf-8"?>
        <configuration>
          <location path="." inheritInChildApplications="false">
            <system.webServer>
              <handlers>
                <add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModuleV2" resourceType="Unspecified" />
              </handlers>
              <aspNetCore processPath="dotnet" arguments=".\MovieReviewApp.dll" stdoutLogEnabled="true" stdoutLogFile=".\logs\stdout" hostingModel="InProcess">
                <environmentVariables>
                  <environmentVariable name="ASPNETCORE_ENVIRONMENT" value="Production" />
                  <environmentVariable name="MOVIEREVIEW_INSTANCE_NAME" value="$instanceName" />
                  <environmentVariable name="MOVIEREVIEW_PORT" value="$instancePort" />
                </environmentVariables>
              </aspNetCore>
            </system.webServer>
          </location>
        </configuration>
        "@
        
        Write-Host "Creating web.config for instance: $instanceName"
        $webConfig | Out-File -FilePath $webConfigPath -Encoding UTF8
        Write-Host "web.config created successfully"
        
    - name: Create/Update IIS Site
      shell: powershell
      run: |
        Import-Module WebAdministration
        
        $instanceName = '${{ matrix.instance.name }}'
        $instancePort = '${{ matrix.instance.port }}'
        $siteName = "MovieReview_$instanceName"
        $appPoolName = "MovieReview_$instanceName"
        $physicalPath = "C:\inetpub\wwwroot\MovieReview_$instanceName"
        
        Write-Host "Configuring IIS for instance: $instanceName"
        Write-Host "Site name: $siteName"
        Write-Host "App pool name: $appPoolName"
        Write-Host "Port: $instancePort"
        Write-Host "Physical path: $physicalPath"
        
        # Check if app pool exists, if not create it
        $existingAppPool = Get-IISAppPool -Name $appPoolName -ErrorAction SilentlyContinue
        if (-not $existingAppPool) {
          New-WebAppPool -Name $appPoolName
          Write-Host "Created app pool: $appPoolName"
        } else {
          Write-Host "App pool already exists: $appPoolName"
        }
        
        # Configure App Pool using correct property paths
        try {
          Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "processModel.identityType" -Value "ApplicationPoolIdentity"
          Write-Host "Set app pool identity to ApplicationPoolIdentity"
        } catch {
          Write-Host "Warning: Could not set app pool identity: $_"
        }
        
        try {
          Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "managedRuntimeVersion" -Value ""
          Write-Host "Set app pool to no managed code"
        } catch {
          Write-Host "Warning: Could not set managed runtime version: $_"
        }
        
        # Create Website if it doesn't exist
        if (-not (Get-Website -Name $siteName -ErrorAction SilentlyContinue)) {
          New-Website -Name $siteName -Port $instancePort -PhysicalPath $physicalPath -ApplicationPool $appPoolName
          Write-Host "Created website: $siteName on port $instancePort"
        } else {
          # Update existing site
          Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name physicalPath -Value $physicalPath
          Set-ItemProperty -Path "IIS:\Sites\$siteName" -Name applicationPool -Value $appPoolName
          
          # Update binding
          Get-WebBinding -Name $siteName | Remove-WebBinding
          New-WebBinding -Name $siteName -Protocol "http" -Port $instancePort -IPAddress "*"
          Write-Host "Updated website: $siteName"
        }
        
    - name: Set directory permissions
      shell: powershell
      run: |
        $instanceName = '${{ matrix.instance.name }}'
        $deployPath = "C:\inetpub\wwwroot\MovieReview_$instanceName"
        $appPoolName = "MovieReview_$instanceName"
        
        Write-Host "Setting permissions for: $deployPath"
        
        # Create required directories (removed wwwroot prefix since we're already in the web root)
        $requiredDirs = @('logs', 'uploads\pending', 'clips', 'sounds', 'temp', 'uploads')
        foreach ($dir in $requiredDirs) {
          $fullDir = Join-Path $deployPath $dir
          if (-not (Test-Path $fullDir)) {
            New-Item -Path $fullDir -ItemType Directory -Force
            Write-Host "Created directory: $fullDir"
          }
        }
        
        # Set permissions for app pool identity (simplified approach)
        $appPoolIdentity = "IIS AppPool\$appPoolName"
        
        try {
          # Grant permissions using icacls directly
          Write-Host "Setting permissions for app pool identity: $appPoolIdentity"
          icacls $deployPath /grant "${appPoolIdentity}:(OI)(CI)F" /T /C
          icacls $deployPath /grant "IIS_IUSRS:(OI)(CI)F" /T /C
          Write-Host "Permissions set successfully"
        } catch {
          Write-Host "Warning: Could not set permissions: $_"
          # Try alternative approach without the problematic SID translation
          Write-Host "Attempting alternative permission setting..."
          icacls $deployPath /grant "Everyone:(OI)(CI)F" /T /C
          Write-Host "Alternative permissions set"
        }
        
    - name: Start IIS Website and App Pool
      shell: powershell
      run: |
        $instanceName = '${{ matrix.instance.name }}'
        $siteName = "MovieReview_$instanceName"
        $appPoolName = "MovieReview_$instanceName"
        
        Write-Host "Starting IIS resources for: $siteName"
        
        try {
          # Stop first to ensure clean restart
          Write-Host "Stopping app pool to ensure clean restart..."
          Stop-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 5
          
          # Start app pool
          Start-WebAppPool -Name $appPoolName
          Write-Host "App pool started"
          
          # Start website
          Start-Website -Name $siteName
          Write-Host "Website started"
          
          # Verify the web.config exists and show its content
          $webConfigPath = "C:\inetpub\wwwroot\MovieReview_$instanceName\web.config"
          if (Test-Path $webConfigPath) {
            Write-Host "Web.config exists at: $webConfigPath"
            $webConfigContent = Get-Content $webConfigPath -Raw
            if ($webConfigContent -like "*MOVIEREVIEW_INSTANCE_NAME*") {
              Write-Host "Environment variable MOVIEREVIEW_INSTANCE_NAME found in web.config"
            } else {
              Write-Host "WARNING: MOVIEREVIEW_INSTANCE_NAME not found in web.config"
            }
          } else {
            Write-Host "WARNING: web.config not found at $webConfigPath"
          }
          
        } catch {
          Write-Host "Warning: Could not start IIS resources: $_"
        }
        
        Start-Sleep -Seconds 20
        
    - name: Health Check
      shell: powershell
      run: |
        $instanceName = '${{ matrix.instance.name }}'
        $instancePort = '${{ matrix.instance.port }}'
        $baseUrl = "http://localhost:$instancePort"
        $healthUrl = "$baseUrl/api/health"
        $instanceHealthUrl = "$baseUrl/api/health/instance/$instanceName"
        
        Write-Host "Performing health checks for instance: $instanceName"
        Write-Host "Base URL: $baseUrl"
        Write-Host "Health URL: $healthUrl"
        Write-Host "Instance Health URL: $instanceHealthUrl"
        
        $maxAttempts = 12
        $attempt = 1
        $healthy = $false
        
        do {
          try {
            Write-Host "Health check attempt $attempt of $maxAttempts"
            
            # First check if the site responds at all
            Write-Host "Testing basic connectivity to: $baseUrl"
            $basicResponse = Invoke-WebRequest -Uri $baseUrl -Method Get -TimeoutSec 30 -UseBasicParsing
            Write-Host "Basic response status: $($basicResponse.StatusCode)"
            
            # Check if health endpoint exists
            Write-Host "Testing health endpoint: $healthUrl"
            try {
              $healthResponse = Invoke-WebRequest -Uri $healthUrl -Method Get -TimeoutSec 30 -UseBasicParsing
              Write-Host "Health endpoint status: $($healthResponse.StatusCode)"
              
              # Try to parse as JSON
              try {
                $healthJson = $healthResponse.Content | ConvertFrom-Json
                Write-Host "Health check JSON response: $($healthJson | ConvertTo-Json -Compress)"
                
                if ($healthJson.isHealthy -eq $true) {
                  Write-Host "Basic health check passed"
                  
                  # Now try instance-specific health check
                  try {
                    $instanceResponse = Invoke-WebRequest -Uri $instanceHealthUrl -Method Get -TimeoutSec 30 -UseBasicParsing
                    $instanceJson = $instanceResponse.Content | ConvertFrom-Json
                    Write-Host "Instance health check JSON response: $($instanceJson | ConvertTo-Json -Compress)"
                    
                    if ($instanceJson.status -eq 'healthy') {
                      $healthy = $true
                      Write-Host "All health checks passed for instance: $instanceName"
                      break
                    } else {
                      Write-Host "Instance health check failed - Status: $($instanceJson.status)"
                    }
                  } catch {
                    Write-Host "Instance health endpoint not available or returned non-JSON: $_"
                    # If instance health check doesn't exist, consider basic health sufficient
                    $healthy = $true
                    Write-Host "Accepting basic health check as sufficient for instance: $instanceName"
                    break
                  }
                } else {
                  Write-Host "Basic health check failed - isHealthy: $($healthJson.isHealthy)"
                }
              } catch {
                Write-Host "Health endpoint returned non-JSON response (length: $($healthResponse.Content.Length))"
                Write-Host "First 200 chars: $($healthResponse.Content.Substring(0, [Math]::Min(200, $healthResponse.Content.Length)))"
              }
            } catch {
              Write-Host "Health endpoint failed: $_"
              
              # If health endpoint doesn't exist, just check if the main site is up
              if ($basicResponse.StatusCode -eq 200) {
                Write-Host "Health endpoint not found, but main site is responding. Considering healthy."
                $healthy = $true
                break
              }
            }
          } catch {
            Write-Host "Basic connectivity failed: $_"
          }
          
          if ($attempt -lt $maxAttempts) {
            Write-Host "Waiting 10 seconds before retry..."
            Start-Sleep -Seconds 10
          }
          
          $attempt++
        } while ($attempt -le $maxAttempts)
        
        if (-not $healthy) {
          # Check logs before failing
          $logsPath = "C:\inetpub\wwwroot\MovieReview_$instanceName\logs\stdout*.log"
          Write-Host "Checking logs at: $logsPath"
          if (Test-Path $logsPath) {
            Write-Host "=== Application Logs ==="
            Get-Content $logsPath -Tail 50 | Write-Host
            Write-Host "=== End Logs ==="
          } else {
            Write-Host "No log files found at: $logsPath"
          }
          
          # Check IIS status
          Write-Host "=== IIS Status ==="
          $siteName = "MovieReview_$instanceName"
          $appPoolName = "MovieReview_$instanceName"
          
          try {
            $site = Get-Website -Name $siteName -ErrorAction SilentlyContinue
            if ($site) {
              Write-Host "Website '$siteName' state: $($site.State)"
            } else {
              Write-Host "Website '$siteName' not found"
            }
            
            $appPool = Get-IISAppPool -Name $appPoolName -ErrorAction SilentlyContinue
            if ($appPool) {
              Write-Host "App pool '$appPoolName' state: $($appPool.State)"
            } else {
              Write-Host "App pool '$appPoolName' not found"
            }
          } catch {
            Write-Host "Error checking IIS status: $_"
          }
          
          Write-Error "Health checks failed for instance: $instanceName after $maxAttempts attempts"
          exit 1
        }