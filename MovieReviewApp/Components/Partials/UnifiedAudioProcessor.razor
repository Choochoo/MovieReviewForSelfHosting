@using MovieReviewApp.Database
@using MovieReviewApp.Models
@using MovieReviewApp.Services
@using System.Globalization
@using System.Text.RegularExpressions
@using MovieReviewApp.Enums
@using Microsoft.AspNetCore.Components.Forms
@inject IWebHostEnvironment WebHostEnvironment
@inject MovieSessionService MovieSessionService
@inject MongoDbService MongoDbService
@inject MovieReviewService MovieReviewService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject GladiaService GladiaService
@inject AudioFileOrganizer AudioOrganizer
@inject MovieSessionAnalysisService AnalysisService
@implements IDisposable

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h3 class="mb-4">ðŸŽ¬ Audio Processing</h3>
        </div>
    </div>

    @if (selectedSession == null)
    {
        <!-- Session Selection/Creation -->
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">Select or Create Session</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <!-- Create New Session -->
                            <div class="col-md-6">
                                <h6>Create New Session</h6>
                                <div class="mb-3">
                                    <label class="form-label">Select Movie</label>
                                    <select class="form-select" @onchange="OnMovieSelected">
                                        <option value="">-- Select a movie --</option>
                                        @if (availableMovies != null)
                                        {
                                            @foreach (var movie in availableMovies)
                                            {
                                                <option value="@movie.Id">
                                                    @movie.Movie - (@movie.StartDate.ToString("MMMM yyyy"))
                                                </option>
                                            }
                                        }
                                    </select>
                                </div>
                                
                                <div class="mb-3">
                                    <ParticipantAssignment 
                                        @bind-MicAssignments="micAssignments"
                                        @bind-PresentSpeakers="presentSpeakers" />
                                </div>

                                <div class="mb-3">
                                    <div class="border border-2 border-dashed rounded p-4 text-center">
                                        <InputFile OnChange="@LoadFiles" multiple accept=".mp3,.wav,.ogg,.aac,.m4a,.mp4,.mov,.avi,.mkv" class="form-control" />
                                        <p class="mt-2 mb-0 text-muted">
                                            <i class="bi bi-cloud-upload"></i> Drop files here or click to browse
                                        </p>
                                    </div>
                                </div>

                                @if (!string.IsNullOrEmpty(errorMessage))
                                {
                                    <div class="alert alert-danger">
                                        <i class="bi bi-exclamation-triangle"></i> @errorMessage
                                    </div>
                                }

                                @if (uploadedFiles.Any())
                                {
                                    <div class="mt-3 mb-3">
                                        <div class="d-flex justify-content-between align-items-center mb-2">
                                            <h6>Selected Files (@uploadedFiles.Count files - @FormatBytes(uploadedFiles.Sum(f => f.FileSize)))</h6>
                                            @if (isProcessing && uploadedFiles.Any(f => f.ProcessingStatus == AudioProcessingStatus.Uploading))
                                            {
                                                <small class="text-muted">
                                                    Uploading files...
                                                </small>
                                            }
                                        </div>
                                        
                                        @if (isProcessing && uploadedFiles.Any(f => f.ProcessingStatus == AudioProcessingStatus.Uploading))
                                        {
                                            <div class="progress mb-3" style="height: 25px;">
                                                <div class="progress-bar progress-bar-striped progress-bar-animated bg-primary" 
                                                     role="progressbar" 
                                                     style="width: 50%;" 
                                                     aria-valuenow="50" 
                                                     aria-valuemin="0" 
                                                     aria-valuemax="100">
                                                    Uploading Files...
                                                </div>
                                            </div>
                                        }
                                        
                                        <div class="list-group">
                                            @foreach (var file in uploadedFiles)
                                            {
                                                <div class="list-group-item">
                                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                                        <div>
                                                            <strong>@file.FileName</strong>
                                                            <br><small class="text-muted">@FormatBytes(file.FileSize)</small>
                                                        </div>
                                                        <div class="d-flex align-items-center">
                                                            <span class="badge @GetStatusBadgeClass(file.ProcessingStatus) me-2">
                                                                @GetStatusIcon(file.ProcessingStatus) @GetStatusText(file.ProcessingStatus)
                                                            </span>
                                                            @if (!isProcessing)
                                                            {
                                                                <button class="btn btn-sm btn-outline-danger" @onclick="() => RemoveFile(file)">
                                                                    <i class="bi bi-x"></i>
                                                                </button>
                                                            }
                                                        </div>
                                                    </div>
                                                    @if (file.ProcessingStatus == AudioProcessingStatus.Uploading || file.ProgressPercentage > 0)
                                                    {
                                                        <div class="mb-1">
                                                            <small class="text-muted">@file.CurrentStep</small>
                                                        </div>
                                                        <div class="progress" style="height: 15px;">
                                                            <div class="progress-bar @GetProgressBarClass(file.ProcessingStatus)" 
                                                                 role="progressbar" 
                                                                 style="width: @file.ProgressPercentage%;" 
                                                                 aria-valuenow="@file.ProgressPercentage" 
                                                                 aria-valuemin="0" 
                                                                 aria-valuemax="100">
                                                                @file.ProgressPercentage%
                                                            </div>
                                                        </div>
                                                    }
                                                </div>
                                            }
                                        </div>
                                    </div>
                                }

                                <div class="mt-3">
                                    <button class="btn btn-primary w-100" 
                                            @onclick="CreateSessionAndConvert" 
                                            disabled="@(!CanCreateSession || isProcessing)"
                                            title="@GetStartButtonTooltip()">
                                        @if (isProcessing)
                                        {
                                            <span class="spinner-border spinner-border-sm me-1"></span>
                                            @if (uploadedFiles.Any(f => f.ProcessingStatus == AudioProcessingStatus.Uploading))
                                            {
                                                <span>Uploading Files...</span>
                                            }
                                            else
                                            {
                                                <span>Processing...</span>
                                            }
                                        }
                                        else
                                        {
                                            <text><i class="bi bi-play-circle"></i> Start Processing</text>
                                        }
                                    </button>
                                    <small class="text-muted d-block mt-1">@GetSessionState()</small>
                                </div>
                            </div>

                            <!-- Load Existing Session -->
                            <div class="col-md-6">
                                <h6>Load Existing Session (@existingSessions.Count sessions found)</h6>
                                @if (existingSessions.Any())
                                {
                                    <div class="list-group">
                                        @foreach (var session in existingSessions.Take(10))
                                        {
                                            <div class="list-group-item d-flex justify-content-between align-items-center">
                                                <div>
                                                    <h6 class="mb-1">@session.MovieTitle</h6>
                                                    <small class="text-muted">
                                                        @session.Date.ToString("MMM dd, yyyy") â€¢ @session.AudioFiles.Count files
                                                        <span class="badge @GetSessionStatusBadgeClass(session.Status) ms-2">@session.Status</span>
                                                    </small>
                                                </div>
                                                <div class="btn-group">
                                                    <button class="btn btn-sm btn-primary" @onclick="() => LoadSession(session)">
                                                        Load
                                                    </button>
                                                    <button class="btn btn-sm btn-outline-danger" @onclick="() => DeleteSession(session)" 
                                                            @onclick:preventDefault="true">
                                                        <i class="bi bi-trash"></i>
                                                    </button>
                                                </div>
                                            </div>
                                        }
                                    </div>
                                }
                                else
                                {
                                    <div class="alert alert-info">
                                        <i class="bi bi-info-circle"></i> No existing sessions found. Process some files first to create sessions that can be loaded later.
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }
    else
    {
        <!-- Session Processing View -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">ðŸŽ¬ @selectedSession.MovieTitle - @selectedSession.Date.ToString("MMM dd, yyyy")</h5>
                        <div>
                            <button class="btn btn-sm btn-light me-2" @onclick="SaveSession" disabled="@isSaving">
                                @if (isSaving)
                                {
                                    <span class="spinner-border spinner-border-sm me-1"></span>
                                }
                                <i class="bi bi-save"></i> Save
                            </button>
                            <button class="btn btn-sm btn-outline-light" @onclick="BackToSelection">
                                <i class="bi bi-arrow-left"></i> Back to Setup
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        @if (selectedSession.AudioFiles.Any())
                        {
                            <!-- Processing Table -->
                            <div class="table-responsive" style="overflow: visible;">
                                <table class="table table-hover" style="overflow: visible;">
                                    <thead>
                                        <tr>
                                            <th style="width: 25%">File</th>
                                            <th style="width: 15%">Status</th>
                                            <th style="width: 35%">Progress</th>
                                            <th style="width: 15%">Actions</th>
                                            <th style="width: 10%">Details</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        @foreach (var file in selectedSession.AudioFiles)
                                        {
                                            <tr class="@GetRowClass(file.ProcessingStatus)">
                                                <td>
                                                    <div>
                                                        <strong>@file.FileName</strong>
                                                        <br><small class="text-muted">@FormatBytes(file.FileSize)</small>
                                                    </div>
                                                </td>
                                                <td>
                                                    <span class="badge @GetStatusBadgeClass(file.ProcessingStatus)">
                                                        @GetStatusIcon(file.ProcessingStatus) @GetStatusText(file.ProcessingStatus)
                                                    </span>
                                                </td>
                                                <td>
                                                    <div class="mb-1">
                                                        <small class="text-muted">@file.CurrentStep</small>
                                                    </div>
                                                    <div class="progress" style="height: 20px;">
                                                        <div class="progress-bar @GetProgressBarClass(file.ProcessingStatus)" 
                                                             role="progressbar" 
                                                             style="width: @file.ProgressPercentage%;" 
                                                             aria-valuenow="@file.ProgressPercentage" 
                                                             aria-valuemin="0" 
                                                             aria-valuemax="100">
                                                            @file.ProgressPercentage%
                                                        </div>
                                                    </div>
                                                </td>
                                                <td>
                                                    @if (IsInProgress(file.ProcessingStatus))
                                                    {
                                                        <button class="btn btn-sm btn-outline-warning" @onclick="() => CancelProcess(file)">
                                                            <i class="bi bi-stop"></i> Stop
                                                        </button>
                                                    }
                                                    else
                                                    {
                                                        <div class="dropdown">
                                                            <button class="btn btn-sm btn-outline-primary dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                                                @GetActionButtonText(file.ProcessingStatus)
                                                            </button>
                                                            <ul class="dropdown-menu" style="position: absolute; z-index: 9999; transform: translateZ(0);">
                                                                @if (CanStartStep(file, AudioProcessingStatus.ConvertingToMp3))
                                                                {
                                                                    <li><a class="dropdown-item" @onclick="() => StartProcess(file, AudioProcessingStatus.ConvertingToMp3)">
                                                                        @(file.ProcessingStatus >= AudioProcessingStatus.ProcessedMp3 ? "Re-convert to MP3" : "Convert to MP3")
                                                                    </a></li>
                                                                }
                                                                @if (CanStartStep(file, AudioProcessingStatus.UploadingToGladia))
                                                                {
                                                                    <li><a class="dropdown-item" @onclick="() => StartProcess(file, AudioProcessingStatus.UploadingToGladia)">
                                                                        @(file.ProcessingStatus >= AudioProcessingStatus.UploadedToGladia ? "Re-upload to Gladia" : "Upload to Gladia")
                                                                    </a></li>
                                                                }
                                                                @if (CanStartStep(file, AudioProcessingStatus.Transcribing))
                                                                {
                                                                    <li><a class="dropdown-item" @onclick="() => StartProcess(file, AudioProcessingStatus.Transcribing)">
                                                                        @(file.ProcessingStatus >= AudioProcessingStatus.TranscriptionComplete ? "Re-transcribe" : "Start Transcription")
                                                                    </a></li>
                                                                }
                                                                @if (CanStartStep(file, AudioProcessingStatus.ProcessingWithAI))
                                                                {
                                                                    <li><a class="dropdown-item" @onclick="() => file.ProcessingStatus >= AudioProcessingStatus.Complete ? RerunAIAnalysis(file) : StartProcess(file, AudioProcessingStatus.ProcessingWithAI)">
                                                                        @(file.ProcessingStatus >= AudioProcessingStatus.Complete ? "Re-run AI Analysis" : "Run AI Analysis")
                                                                    </a></li>
                                                                }
                                                                @if (file.ProcessingStatus == AudioProcessingStatus.Complete)
                                                                {
                                                                    <li><hr class="dropdown-divider"></li>
                                                                    <li><a class="dropdown-item" @onclick="() => StartFullProcessing(file)">
                                                                        <i class="bi bi-arrow-clockwise"></i> Restart Full Process
                                                                    </a></li>
                                                                }
                                                            </ul>
                                                        </div>
                                                    }
                                                </td>
                                                <td>
                                                    <button class="btn btn-sm btn-outline-info" data-bs-toggle="collapse" data-bs-target="#details-@file.FileName.Replace(".", "-")">
                                                        <i class="bi bi-info-circle"></i>
                                                    </button>
                                                </td>
                                            </tr>
                                            <!-- Expandable Details Row -->
                                            <tr class="collapse" id="details-@file.FileName.Replace(".", "-")">
                                                <td colspan="5">
                                                    <div class="card card-body bg-light">
                                                        <div class="row">
                                                            <div class="col-md-6">
                                                                <strong>Processing Details:</strong>
                                                                <ul class="mb-2">
                                                                    <li>File Path: <code>@file.FilePath</code></li>
                                                                    <li>Speaker: @(file.SpeakerNumber?.ToString() ?? "Unknown")</li>
                                                                    <li>Master Recording: @(file.IsMasterRecording ? "Yes" : "No")</li>
                                                                    <li>Last Updated: @file.LastUpdated.ToString("HH:mm:ss")</li>
                                                                </ul>
                                                            </div>
                                                            <div class="col-md-6">
                                                                @if (!string.IsNullOrEmpty(file.ConversionError))
                                                                {
                                                                    <strong class="text-danger">Error:</strong>
                                                                    <p class="text-danger">@file.ConversionError</p>
                                                                }
                                                                @if (!string.IsNullOrEmpty(file.TranscriptText))
                                                                {
                                                                    <strong>Transcript Preview:</strong>
                                                                    <p class="small text-muted">@(file.TranscriptText.Length > 200 ? file.TranscriptText.Substring(0, 200) + "..." : file.TranscriptText)</p>
                                                                }
                                                            </div>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                        }
                                    </tbody>
                                </table>
                            </div>

                            <!-- Bulk Actions -->
                            <div class="row mt-4">
                                <div class="col-md-6">
                                    <h6>Process Files</h6>
                                    <div class="dropdown">
                                        <button class="btn btn-success dropdown-toggle" type="button" id="processDropdown" data-bs-toggle="dropdown" aria-expanded="false" disabled="@isProcessing">
                                            <i class="bi bi-play-circle"></i> Process All Files From...
                                        </button>
                                        <ul class="dropdown-menu" aria-labelledby="processDropdown">
                                            <li><a class="dropdown-item" @onclick="() => StartBulkProcessing(AudioProcessingStatus.ConvertingToMp3)">
                                                <i class="bi bi-file-music"></i> Start from WAV â†’ MP3 Conversion
                                            </a></li>
                                            <li><a class="dropdown-item" @onclick="() => StartBulkProcessing(AudioProcessingStatus.UploadingToGladia)">
                                                <i class="bi bi-cloud-upload"></i> Start from Upload to Gladia
                                            </a></li>
                                            <li><a class="dropdown-item" @onclick="() => StartBulkProcessing(AudioProcessingStatus.Transcribing)">
                                                <i class="bi bi-mic"></i> Start from Transcription
                                            </a></li>
                                            <li><a class="dropdown-item" @onclick="() => StartBulkProcessing(AudioProcessingStatus.ProcessingWithAI)">
                                                <i class="bi bi-robot"></i> Start from AI Analysis
                                            </a></li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="col-md-6 text-end">
                                    <h6>Session Progress</h6>
                                    <div class="progress" style="height: 30px;">
                                        <div class="progress-bar bg-success" 
                                             role="progressbar" 
                                             style="width: @GetOverallProgress()%;">
                                            @GetOverallProgress()% Complete
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }
                        else
                        {
                            <div class="alert alert-info">
                                <i class="bi bi-info-circle"></i> No audio files found in this session.
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    }
</div>

@code {
    private const string MIC_ASSIGNMENTS_KEY = "micAssignments";
    private const string PRESENT_SPEAKERS_KEY = "presentSpeakers";
    private MovieSession? selectedSession;
    private List<MovieEvent>? availableMovies;
    private List<MovieSession> existingSessions = new();
    private Dictionary<int, string> micAssignments = new();
    private HashSet<int> presentSpeakers = new();
    private List<AudioFile> uploadedFiles = new();
    private List<IBrowserFile> selectedFiles = new();
    private Guid? selectedMovieId;
    private string errorMessage = string.Empty;
    private bool isProcessing = false;
    private bool isSaving = false;
    private Timer? transcriptionStatusTimer;

    private bool CanCreateSession => selectedMovieId.HasValue && selectedFiles.Any() && presentSpeakers.Any();

    protected override async Task OnInitializedAsync()
    {
        availableMovies = await MovieReviewService.GetAllMovieEventsAsync();
        await LoadExistingSessions();
        await LoadCachedAssignments();
    }

    private async Task LoadExistingSessions()
    {
        // Load all sessions, not just completed ones, so users can see and work with processed files
        existingSessions = await MovieSessionService.GetAllSessions();
        
        // Sort by creation date (most recent first) and take the most recent 20
        existingSessions = existingSessions
            .OrderByDescending(s => s.CreatedAt)
            .ThenByDescending(s => s.Date)
            .Take(20)
            .ToList();
        
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadCachedAssignments()
    {
        try
        {
            // Load mic assignments
            var cachedAssignments = await JSRuntime.InvokeAsync<string>("localStorage.getItem", MIC_ASSIGNMENTS_KEY);
            if (!string.IsNullOrEmpty(cachedAssignments))
            {
                micAssignments = System.Text.Json.JsonSerializer.Deserialize<Dictionary<int, string>>(cachedAssignments) ?? new();
            }

            // Load present speakers
            var cachedSpeakers = await JSRuntime.InvokeAsync<string>("localStorage.getItem", PRESENT_SPEAKERS_KEY);
            if (!string.IsNullOrEmpty(cachedSpeakers))
            {
                presentSpeakers = System.Text.Json.JsonSerializer.Deserialize<HashSet<int>>(cachedSpeakers) ?? new();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading cached assignments: {ex}");
            // If there's any error loading from cache, start with empty collections
            micAssignments = new();
            presentSpeakers = new();
        }
    }

    private async Task SaveAssignmentsToCache()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", 
                MIC_ASSIGNMENTS_KEY, 
                System.Text.Json.JsonSerializer.Serialize(micAssignments));

            await JSRuntime.InvokeVoidAsync("localStorage.setItem", 
                PRESENT_SPEAKERS_KEY, 
                System.Text.Json.JsonSerializer.Serialize(presentSpeakers));
        }
        catch
        {
            // Silently fail if we can't save to cache
        }
    }

    private async Task OnMovieSelected(ChangeEventArgs e)
    {
        var movieIdStr = e.Value?.ToString();
        selectedMovieId = !string.IsNullOrEmpty(movieIdStr) && Guid.TryParse(movieIdStr, out var movieId) ? movieId : null;
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadFiles(InputFileChangeEventArgs e)
    {
        errorMessage = string.Empty;
        selectedFiles = e.GetMultipleFiles(maximumFileCount: 20).ToList();
        
        Console.WriteLine($"DEBUG: LoadFiles called with {selectedFiles.Count} files");
        
        // Just prepare the file list for display - no upload yet
        uploadedFiles.Clear();
        
        foreach (var file in selectedFiles)
        {
            if (IsAudioFile(file.Name))
            {
                Console.WriteLine($"DEBUG: Adding {file.Name} to upload queue");
                
                var audioFile = new AudioFile
                {
                    FileName = file.Name,
                    FilePath = string.Empty, // Will be set during upload
                    FileSize = file.Size,
                    ProcessingStatus = AudioProcessingStatus.Pending,
                    CurrentStep = "Ready to upload",
                    ProgressPercentage = 0,
                    CanRetry = true
                };
                
                uploadedFiles.Add(audioFile);
            }
        }
        
        Console.WriteLine($"DEBUG: LoadFiles completed, {uploadedFiles.Count} files ready for upload");
        await InvokeAsync(StateHasChanged);
    }

    private void RemoveFile(AudioFile file)
    {
        // Find the index of the file being removed
        var fileIndex = uploadedFiles.IndexOf(file);
        
        // Remove from uploadedFiles
        uploadedFiles.Remove(file);
        
        // Remove from selectedFiles if index is valid
        if (fileIndex >= 0 && fileIndex < selectedFiles.Count)
        {
            selectedFiles.RemoveAt(fileIndex);
        }
        
        StateHasChanged();
    }

    private async Task CreateSessionAndConvert()
    {
        if (!CanCreateSession) return;

        isProcessing = true;
        errorMessage = string.Empty;

        try
        {
            var movie = availableMovies?.FirstOrDefault(m => m.Id == selectedMovieId);
            if (movie == null)
            {
                errorMessage = "Selected movie not found.";
                return;
            }

            Console.WriteLine($"DEBUG: CreateSessionAndConvert starting with {uploadedFiles.Count} files to upload");

            // Create temp directory if it doesn't exist
            var tempDir = Path.Combine(WebHostEnvironment.WebRootPath, "temp");
            Directory.CreateDirectory(tempDir);

            // Calculate total upload progress
            long totalBytes = uploadedFiles.Sum(f => f.FileSize);
            long uploadedBytes = 0;
            int currentFileIndex = 0;

            Console.WriteLine($"DEBUG: Total upload size: {FormatBytes(totalBytes)}");

            // Upload files sequentially with progress
            for (int i = 0; i < uploadedFiles.Count && i < selectedFiles.Count; i++)
            {
                var audioFile = uploadedFiles[i];
                var browserFile = selectedFiles[i];
                currentFileIndex = i + 1;

                Console.WriteLine($"DEBUG: Starting upload for file {currentFileIndex}/{uploadedFiles.Count}: {audioFile.FileName}");

                // Set file path
                var tempPath = Path.Combine(tempDir, audioFile.FileName);
                audioFile.FilePath = tempPath;

                // Update status for current file
                audioFile.ProcessingStatus = AudioProcessingStatus.Uploading;
                audioFile.CurrentStep = "Uploading file";
                audioFile.ProgressPercentage = 0;

                // Update overall progress display
                var overallProgress = (int)((double)uploadedBytes / totalBytes * 100);
                Console.WriteLine($"DEBUG: Overall progress: {overallProgress}% ({FormatBytes(uploadedBytes)}/{FormatBytes(totalBytes)})");

                await InvokeAsync(StateHasChanged);

                try
                {
                    // Upload the file with progress tracking
                    using var stream = browserFile.OpenReadStream(maxAllowedSize: 10L * 1024 * 1024 * 1024);
                    using var fileStream = new FileStream(tempPath, FileMode.Create);

                    var buffer = new byte[(1024 * 1024)*30]; // 30MB buffer
                    int bytesRead;
                    long fileBytesRead = 0;

                    while ((bytesRead = await stream.ReadAsync(buffer)) > 0)
                    {
                        await fileStream.WriteAsync(buffer.AsMemory(0, bytesRead));
                        fileBytesRead += bytesRead;
                        uploadedBytes += bytesRead;

                        // Update file progress
                        audioFile.ProgressPercentage = (int)((double)fileBytesRead / audioFile.FileSize * 100);
                        
                        // Update overall progress
                        overallProgress = (int)((double)uploadedBytes / totalBytes * 100);
                        audioFile.CurrentStep = "Uploading file";

                        // Update UI every 5% or so to avoid too many updates
                        if (fileBytesRead % (audioFile.FileSize / 20 + 1) < bytesRead)
                        {
                            await InvokeAsync(StateHasChanged);
                        }
                    }

                    // Mark file as uploaded
                    audioFile.ProcessingStatus = AudioProcessingStatus.Pending;
                    audioFile.CurrentStep = "Ready to process";
                    audioFile.ProgressPercentage = 100;
                    
                    Console.WriteLine($"DEBUG: Successfully uploaded {audioFile.FileName}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"DEBUG ERROR: Failed to upload {audioFile.FileName}: {ex.Message}");
                    audioFile.ProcessingStatus = AudioProcessingStatus.Failed;
                    audioFile.ConversionError = $"Upload failed: {ex.Message}";
                    audioFile.CurrentStep = "Upload failed";
                    audioFile.CanRetry = true;
                    
                    // Still count the bytes for overall progress
                    uploadedBytes += audioFile.FileSize;
                }

                await InvokeAsync(StateHasChanged);
            }

            Console.WriteLine($"DEBUG: All uploads completed");

            // Check for existing sessions with the same movie title and date
            var existingSessions = await MongoDbService.FindAsync<MovieSession>(s => 
                s.MovieTitle == movie.Movie && 
                s.Date.Date == movie.StartDate.Date);

            // Delete any existing sessions for this movie event
            foreach (var existingSession in existingSessions)
            {
                Console.WriteLine($"DEBUG: Deleting existing session {existingSession.Id} for {existingSession.MovieTitle}");
                
                // Also try to delete the folder if it exists
                if (!string.IsNullOrEmpty(existingSession.FolderPath) && Directory.Exists(existingSession.FolderPath))
                {
                    try
                    {
                        Directory.Delete(existingSession.FolderPath, recursive: true);
                        Console.WriteLine($"DEBUG: Deleted existing session folder: {existingSession.FolderPath}");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"DEBUG WARNING: Could not delete existing session folder: {ex.Message}");
                    }
                }
                
                await MongoDbService.DeleteByIdAsync<MovieSession>(existingSession.Id);
            }

            // Create session folder structure
            var sessionDate = movie.StartDate.Date;
            var sessionFolderName = $"{sessionDate:yyyy-MM-dd}_{movie.Movie?.Replace(" ", "_").Replace(":", "").Replace("?", "")}";
            var sessionFolderPath = Path.Combine(WebHostEnvironment.WebRootPath, "uploads", "sessions", sessionFolderName);
            
            // Create the session folder
            Directory.CreateDirectory(sessionFolderPath);
            Console.WriteLine($"DEBUG: Created session folder: {sessionFolderPath}");

            // Initialize audio folder structure using AudioOrganizer
            AudioOrganizer.InitializeAudioFolders(sessionFolderPath);

            // Create session with the uploaded audio files and proper folder path
            selectedSession = new MovieSession
            {
                Id = Guid.NewGuid(),
                MovieTitle = movie.Movie ?? string.Empty,
                Date = sessionDate,
                FolderPath = sessionFolderPath, // Set the folder path!
                Status = ProcessingStatus.Pending, // Explicitly set initial status
                MicAssignments = new Dictionary<int, string>(micAssignments),
                ParticipantsPresent = presentSpeakers.Select(s => micAssignments.TryGetValue(s, out var name) ? name : $"Speaker {s + 1}").ToList(),
                AudioFiles = uploadedFiles.ToList()
            };

            // Move uploaded files from temp directly to session folder (flat structure)
            for (int i = 0; i < selectedSession.AudioFiles.Count; i++)
            {
                var audioFile = selectedSession.AudioFiles[i];
                var tempPath = audioFile.FilePath;
                var newPath = Path.Combine(sessionFolderPath, audioFile.FileName);
                
                try
                {
                    if (File.Exists(tempPath))
                    {
                        File.Move(tempPath, newPath);
                        audioFile.FilePath = newPath;
                        Console.WriteLine($"DEBUG: Moved {audioFile.FileName} to session folder");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"DEBUG ERROR: Failed to move {audioFile.FileName}: {ex.Message}");
                    // Keep the temp path if move fails
                }
            }

            // IMPORTANT: Detect and rename master recording files (like the old system)
            await DetectAndRenameMasterRecording(selectedSession);
            
            // Analyze files for speaker assignments
            AnalyzeAudioFiles(selectedSession);

            // Save the session
            await MongoDbService.UpsertAsync(selectedSession);
            Console.WriteLine($"DEBUG: Session saved to database with {selectedSession.AudioFiles.Count} files");

            await InvokeAsync(StateHasChanged);

            // Start the processing workflow automatically from the beginning
            Console.WriteLine($"DEBUG: Starting automatic processing workflow");
            await StartBulkProcessing(AudioProcessingStatus.ConvertingToMp3);
            Console.WriteLine($"DEBUG: Automatic processing workflow started successfully");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"DEBUG ERROR: CreateSessionAndConvert failed: {ex.Message}");
            Console.WriteLine($"DEBUG ERROR: Full exception: {ex}");
            errorMessage = $"Error creating session: {ex.Message}";
        }
        finally
        {
            Console.WriteLine($"DEBUG: CreateSessionAndConvert completed");
            isProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task LoadSession(MovieSession session)
    {
        selectedSession = session;
        micAssignments = new Dictionary<int, string>(session.MicAssignments);
        presentSpeakers = session.MicAssignments.Keys.ToHashSet();
        
        // Check for files in progress and resume monitoring
        await ResumeInProgressTranscriptions();
        
        await InvokeAsync(StateHasChanged);
    }

    private async Task DeleteSession(MovieSession session)
    {
        if (await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to delete the session for '{session.MovieTitle}'? This action cannot be undone."))
        {
            await MongoDbService.DeleteByIdAsync<MovieSession>(session.Id);
            await LoadExistingSessions();
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SaveSession()
    {
        if (selectedSession == null) return;
        
        isSaving = true;
        try
        {
            await MongoDbService.UpsertAsync(selectedSession);
            
            // Return to selection view after successful save
            BackToSelection();
        }
        finally
        {
            isSaving = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void BackToSelection()
    {
        selectedSession = null;
        selectedMovieId = null;
        micAssignments.Clear();
        presentSpeakers.Clear();
        selectedFiles.Clear();
        errorMessage = string.Empty;
    }

    private async Task StartProcess(AudioFile file, AudioProcessingStatus targetStatus)
    {
        try
        {
            file.ProcessingStatus = targetStatus;
            file.ProgressPercentage = 0;
            file.CurrentStep = GetStatusText(targetStatus);
            file.LastUpdated = DateTime.UtcNow;
            file.CanRetry = false;
            file.ConversionError = string.Empty;

            // Force immediate UI update
            await InvokeAsync(StateHasChanged);
            await MongoDbService.UpsertAsync(selectedSession!);

            switch (targetStatus)
            {
                case AudioProcessingStatus.Pending:
                    // Determine appropriate next step based on file state
                    if (!File.Exists(file.FilePath))
                    {
                        throw new Exception($"File not found at path: {file.FilePath}");
                    }
                    
                    var extension = Path.GetExtension(file.FilePath).ToLowerInvariant();
                    var nextStatus = extension == ".mp3" ? AudioProcessingStatus.UploadingToGladia : AudioProcessingStatus.ConvertingToMp3;
                    
                    file.CurrentStep = "Determining next step...";
                    await MongoDbService.UpsertAsync(selectedSession!);
                    await StartProcess(file, nextStatus);
                    break;

                case AudioProcessingStatus.Uploading:
                    // Files are now uploaded during session creation, so skip directly to MP3 conversion
                    if (!File.Exists(file.FilePath))
                    {
                        throw new Exception($"File not found at path: {file.FilePath}");
                    }
                    
                    // Mark as uploaded and move to MP3 conversion
                    file.ProcessingStatus = AudioProcessingStatus.Pending;
                    file.CurrentStep = "File uploaded, ready for conversion";
                    await MongoDbService.UpsertAsync(selectedSession!);
                    await StartProcess(file, AudioProcessingStatus.ConvertingToMp3);
                    break;

                case AudioProcessingStatus.ConvertingToMp3:
                    if (!File.Exists(file.FilePath))
                    {
                        throw new Exception($"File not found at path: {file.FilePath}");
                    }
                    
                    // Reset progress at start
                    file.ProgressPercentage = 0;
                    file.CurrentStep = "Starting MP3 conversion";
                    await InvokeAsync(StateHasChanged);
                    await MongoDbService.UpsertAsync(selectedSession!);
                    
                    // Since FFmpeg doesn't report progress, we'll simulate it
                    var progressCts = new CancellationTokenSource();
                    var progressTask = Task.Run(async () =>
                    {
                        try
                        {
                            for (int p = 10; p <= 90; p += 10)
                            {
                                if (progressCts.Token.IsCancellationRequested) break;
                                
                                file.ProgressPercentage = p;
                                file.CurrentStep = $"Converting to MP3... {p}%";
                                await InvokeAsync(StateHasChanged);
                                
                                await Task.Delay(500, progressCts.Token);
                            }
                        }
                        catch (OperationCanceledException)
                        {
                            // Expected when cancelled
                        }
                    }, progressCts.Token);
                    
                    // Real MP3 conversion using GladiaService
                    var conversionResults = await GladiaService.ConvertAllWavsToMp3Async(
                        new List<AudioFile> { file }, 
                        selectedSession!.FolderPath,
                        (step, current, total) => 
                        {
                            // This callback is for file-by-file progress, not conversion progress
                            Console.WriteLine($"DEBUG: MP3 Conversion - {step}");
                        });

                    // Cancel the progress simulation
                    progressCts.Cancel();

                    var result = conversionResults.FirstOrDefault();
                    if (result.success)
                    {
                        // Note: ProcessingStatus and FilePath are already updated by GladiaService
                        // Don't override them here
                        file.CurrentStep = "MP3 conversion complete";
                        file.ProgressPercentage = 100;
                        file.CanRetry = true;
                        await InvokeAsync(StateHasChanged);
                        await MongoDbService.UpsertAsync(selectedSession!);
                        
                        // Update session progress
                        await UpdateSessionProgress();
                        
                        // After conversion, move to Gladia upload
                        await StartProcess(file, AudioProcessingStatus.UploadingToGladia);
                    }
                    else
                    {
                        file.ProcessingStatus = AudioProcessingStatus.FailedMp3;
                        file.ConversionError = result.error;
                        file.CurrentStep = "MP3 conversion failed";
                        file.CanRetry = true;
                        throw new Exception(result.error ?? "MP3 conversion failed");
                    }
                    break;

                case AudioProcessingStatus.UploadingToGladia:
                    // Reset progress at start
                    file.ProgressPercentage = 0;
                    file.CurrentStep = "Starting upload to Gladia";
                    await InvokeAsync(StateHasChanged);
                    await MongoDbService.UpsertAsync(selectedSession!);
                    
                    // Real Gladia upload
                    var uploadResults = await GladiaService.UploadAllMp3sToGladiaAsync(
                        new List<AudioFile> { file },
                        selectedSession!.FolderPath,
                        (step, current, total) => 
                        {
                            // Since this is also file-by-file, simulate progress
                            var progress = Math.Min(95, file.ProgressPercentage + 15);
                            file.ProgressPercentage = progress;
                            file.CurrentStep = $"Uploading to Gladia... {progress}%";
                            file.LastUpdated = DateTime.UtcNow;
                            Console.WriteLine($"DEBUG: Upload Progress - {file.FileName}: {progress}% - {step}");
                            
                            InvokeAsync(StateHasChanged);
                        },
                        selectedSession!,
                        async (s) => await MongoDbService.UpsertAsync(s));

                    var uploadResult = uploadResults.FirstOrDefault();
                    if (uploadResult.success)
                    {
                        file.ProcessingStatus = AudioProcessingStatus.UploadedToGladia;
                        file.CurrentStep = "Upload complete";
                        file.ProgressPercentage = 100;
                        file.CanRetry = true;
                        await InvokeAsync(StateHasChanged);
                        await MongoDbService.UpsertAsync(selectedSession!);
                        
                        // Update session progress
                        await UpdateSessionProgress();
                        
                        // After upload, move to transcription
                        await StartProcess(file, AudioProcessingStatus.Transcribing);
                    }
                    else
                    {
                        file.ProcessingStatus = AudioProcessingStatus.Failed;
                        file.ConversionError = uploadResult.error;
                        file.CurrentStep = "Upload failed";
                        file.CanRetry = true;
                        throw new Exception(uploadResult.error ?? "Upload to Gladia failed");
                    }
                    break;

                case AudioProcessingStatus.Transcribing:
                    // Real transcription using Gladia
                    if (string.IsNullOrEmpty(file.AudioUrl))
                    {
                        throw new Exception("File must be uploaded to Gladia before transcription");
                    }

                    file.CurrentStep = "Starting transcription";
                    file.ProgressPercentage = 10;
                    await MongoDbService.UpsertAsync(selectedSession!);
                    await InvokeAsync(StateHasChanged);

                    // Determine speaker count
                    var speakerCount = selectedSession!.ParticipantsPresent.Count;
                    var fileName = Path.GetFileName(file.FilePath);
                    
                    // Start transcription
                    var transcriptionId = await GladiaService.StartTranscriptionAsync(
                        file.AudioUrl, 
                        speakerCount, 
                        enableSpeakerDiarization: true,
                        fileName);

                    file.TranscriptId = transcriptionId;
                    file.CurrentStep = "Transcription in progress";
                    file.ProgressPercentage = 30;
                    await MongoDbService.UpsertAsync(selectedSession!);
                    await InvokeAsync(StateHasChanged);

                    // Wait for completion and get result
                    var transcriptionResult = await GladiaService.WaitForTranscriptionAsync(transcriptionId);
                    
                    // Build transcript from utterances with proper speaker mapping
                    file.TranscriptText = selectedSession!.MicAssignments != null && selectedSession.MicAssignments.Any()
                        ? GladiaService.BuildTranscriptFromUtterances(transcriptionResult, selectedSession.MicAssignments, fileName)
                        : transcriptionResult.result?.transcription?.full_transcript ?? string.Empty;

                    file.ProcessingStatus = AudioProcessingStatus.TranscriptionComplete;
                    file.CurrentStep = "Transcription complete";
                    file.ProgressPercentage = 100;
                    file.ProcessedAt = DateTime.UtcNow;
                    await MongoDbService.UpsertAsync(selectedSession!);
                    await InvokeAsync(StateHasChanged);
                    
                    // Update session progress
                    await UpdateSessionProgress();

                    // After transcription, move to AI processing
                    await StartProcess(file, AudioProcessingStatus.ProcessingWithAI);
                    break;

                case AudioProcessingStatus.ProcessingWithAI:
                    // AI analysis is a SESSION-LEVEL operation, not per-file
                    // Only run it once when triggered, and update all files together
                    await RunSessionAIAnalysis();
                    break;

                default:
                    throw new Exception($"Invalid processing status: {targetStatus}");
            }

            await MongoDbService.UpsertAsync(selectedSession!);
        }
        catch (Exception ex)
        {
            file.ProcessingStatus = AudioProcessingStatus.Failed;
            file.ConversionError = ex.Message;
            file.CurrentStep = $"Error: {ex.Message}";
            await MongoDbService.UpsertAsync(selectedSession!);
            throw; // Re-throw to be caught by StartBulkProcessing
        }
        finally
        {
            file.CanRetry = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task CancelProcess(AudioFile file)
    {
        file.ProcessingStatus = AudioProcessingStatus.Failed;
        file.CurrentStep = "Cancelled by user";
        file.CanRetry = true;
        await InvokeAsync(StateHasChanged);
    }

    private async Task StartBulkProcessing(AudioProcessingStatus startingStatus)
    {
        if (selectedSession == null) return;
        
        Console.WriteLine($"DEBUG: StartBulkProcessing beginning from {startingStatus} with {selectedSession.AudioFiles.Count} files");
        isProcessing = true;
        errorMessage = string.Empty;
        
        try 
        {
            // First, prepare all files and determine what needs to be done
            var filesToProcess = new List<AudioFile>();
            
            for (int i = 0; i < selectedSession.AudioFiles.Count; i++)
            {
                var file = selectedSession.AudioFiles[i];
                Console.WriteLine($"DEBUG: Preparing file {i+1}/{selectedSession.AudioFiles.Count}: {file.FileName} (Current Status: {file.ProcessingStatus})");
                
                // Reset any failed states
                if (file.ProcessingStatus == AudioProcessingStatus.Failed || 
                    file.ProcessingStatus == AudioProcessingStatus.FailedMp3)
                {
                    file.ProcessingStatus = AudioProcessingStatus.Pending;
                    file.ConversionError = string.Empty;
                }
                
                // Determine the actual starting point based on user selection and file state
                var actualStartingStatus = DetermineStartingStatus(file, startingStatus);
                
                if (actualStartingStatus != null)
                {
                    Console.WriteLine($"DEBUG: {file.FileName} will start from {actualStartingStatus}");
                    filesToProcess.Add(file);
                }
                else
                {
                    Console.WriteLine($"DEBUG: File {file.FileName} is already complete or doesn't need processing from {startingStatus}");
                }
            }
            
            if (!filesToProcess.Any())
            {
                Console.WriteLine($"DEBUG: No files need processing from {startingStatus}");
                return;
            }
            
            // Determine which phases need to run based on the user's requested starting point
            // When user requests a specific step, we need to reset files to that step and run from there
            var needsConversion = startingStatus == AudioProcessingStatus.ConvertingToMp3;
            var needsUpload = startingStatus <= AudioProcessingStatus.UploadingToGladia && filesToProcess.Any();
            var needsTranscription = startingStatus <= AudioProcessingStatus.Transcribing && filesToProcess.Any();
            var needsAIAnalysis = startingStatus <= AudioProcessingStatus.ProcessingWithAI && filesToProcess.Any();
            
            Console.WriteLine($"DEBUG: Processing phases needed - Conversion: {needsConversion}, Upload: {needsUpload}, Transcription: {needsTranscription}, AI: {needsAIAnalysis}");
            
            // Reset file statuses to the requested starting point (this allows "downgrading" from Complete to earlier steps)
            foreach (var file in filesToProcess)
            {
                var oldStatus = file.ProcessingStatus;
                
                // Reset to the requested starting status (or the step before it to trigger the requested step)
                file.ProcessingStatus = startingStatus switch
                {
                    AudioProcessingStatus.ConvertingToMp3 => AudioProcessingStatus.Pending,
                    AudioProcessingStatus.UploadingToGladia => AudioProcessingStatus.ProcessedMp3, 
                    AudioProcessingStatus.Transcribing => AudioProcessingStatus.UploadedToGladia,
                    AudioProcessingStatus.ProcessingWithAI => AudioProcessingStatus.TranscriptionComplete,
                    _ => file.ProcessingStatus
                };
                
                file.ProgressPercentage = 0;
                file.CurrentStep = "Ready to restart processing";
                file.ConversionError = string.Empty;
                file.CanRetry = false;
                
                if (oldStatus != file.ProcessingStatus)
                {
                    Console.WriteLine($"DEBUG: Reset {file.FileName} status from {oldStatus} to {file.ProcessingStatus} for reprocessing");
                }
            }
            
            // Save the status changes
            await MongoDbService.UpsertAsync(selectedSession!);
            await InvokeAsync(StateHasChanged);
            
            // Run phases in order, but only if needed
            if (needsConversion)
            {
                await ProcessMp3ConversionPhase(filesToProcess);
            }
            
            if (needsUpload)
            {
                await ProcessGladiaUploadPhase(filesToProcess);
            }
            
            if (needsTranscription)
            {
                await ProcessTranscriptionPhase(filesToProcess);
            }
            
            if (needsAIAnalysis)
            {
                await ProcessAIAnalysisPhase(filesToProcess);
            }
            
            Console.WriteLine($"DEBUG: Completed all necessary processing phases for {filesToProcess.Count} files");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"DEBUG: Error in bulk processing: {ex.Message}");
            errorMessage = $"Error in bulk processing: {ex.Message}";
        }
        finally
        {
            isProcessing = false;
            Console.WriteLine($"DEBUG: StartBulkProcessing completed");
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private async Task ProcessMp3ConversionPhase(List<AudioFile> files)
    {
        var wavFiles = files.Where(f => Path.GetExtension(f.FilePath).ToLowerInvariant() == ".wav").ToList();
        if (!wavFiles.Any()) return;
        
        Console.WriteLine($"DEBUG: Starting MP3 conversion phase for {wavFiles.Count} WAV files");
        
        var conversionResults = await GladiaService.ConvertAllWavsToMp3Async(
            wavFiles,
            selectedSession!.FolderPath,
            (step, current, total) => 
            {
                Console.WriteLine($"DEBUG: MP3 Conversion - {step}");
            });
            
        // Update UI after conversion batch
        await MongoDbService.UpsertAsync(selectedSession!);
        await InvokeAsync(StateHasChanged);
        await UpdateSessionProgress();
        
        Console.WriteLine($"DEBUG: MP3 conversion phase completed. {conversionResults.Count(r => r.success)} successful, {conversionResults.Count(r => !r.success)} failed");
    }
    
    private async Task ProcessGladiaUploadPhase(List<AudioFile> files)
    {
        var mp3Files = files.Where(f => 
            string.IsNullOrEmpty(f.AudioUrl) && 
            Path.GetExtension(f.FilePath).ToLowerInvariant() == ".mp3").ToList();
        if (!mp3Files.Any()) return;
        
        Console.WriteLine($"DEBUG: Starting Gladia upload phase for {mp3Files.Count} MP3 files");
        
        var uploadResults = await GladiaService.UploadAllMp3sToGladiaAsync(
            mp3Files,
            selectedSession!.FolderPath,
            (step, current, total) => 
            {
                Console.WriteLine($"DEBUG: Upload Progress - {step}");
            },
            selectedSession!,
            async (s) => await MongoDbService.UpsertAsync(s));
            
        // Update UI after upload batch
        await MongoDbService.UpsertAsync(selectedSession!);
        await InvokeAsync(StateHasChanged);
        await UpdateSessionProgress();
        
        Console.WriteLine($"DEBUG: Gladia upload phase completed. {uploadResults.Count(r => r.success)} successful, {uploadResults.Count(r => !r.success)} failed");
    }
    
    private async Task ProcessTranscriptionPhase(List<AudioFile> files)
    {
        var readyFiles = files.Where(f => 
            !string.IsNullOrEmpty(f.AudioUrl) && 
            f.ProcessingStatus < AudioProcessingStatus.TranscriptionComplete).ToList();
        if (!readyFiles.Any()) return;
        
        Console.WriteLine($"DEBUG: Starting transcription phase for {readyFiles.Count} files");
        
        foreach (var file in readyFiles)
        {
            try
            {
                await StartProcess(file, AudioProcessingStatus.Transcribing);
                Console.WriteLine($"DEBUG: Transcription completed for {file.FileName}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DEBUG: Transcription failed for {file.FileName}: {ex.Message}");
                file.ProcessingStatus = AudioProcessingStatus.Failed;
                file.ConversionError = ex.Message;
            }
        }
        
        // Update UI after transcription batch
        await MongoDbService.UpsertAsync(selectedSession!);
        await InvokeAsync(StateHasChanged);
        await UpdateSessionProgress();
        
        Console.WriteLine($"DEBUG: Transcription phase completed");
    }
    
    private async Task ProcessAIAnalysisPhase(List<AudioFile> files)
    {
        var readyFiles = files.Where(f => 
            f.ProcessingStatus >= AudioProcessingStatus.TranscriptionComplete &&
            f.ProcessingStatus < AudioProcessingStatus.Complete).ToList();
        if (!readyFiles.Any()) return;
        
        Console.WriteLine($"DEBUG: Starting session-level AI analysis for {readyFiles.Count} files");
        
        try
        {
            // AI analysis is SESSION-LEVEL - run once for all files
            await RunSessionAIAnalysis();
            Console.WriteLine($"DEBUG: Session AI analysis completed successfully");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"DEBUG: Session AI analysis failed: {ex.Message}");
            
            // Mark all ready files as failed
            foreach (var file in readyFiles)
            {
                file.ProcessingStatus = AudioProcessingStatus.Failed;
                file.ConversionError = ex.Message;
                file.CurrentStep = "AI analysis failed";
            }
        }
        
        // Update UI after AI analysis
        await MongoDbService.UpsertAsync(selectedSession!);
        await InvokeAsync(StateHasChanged);
        await UpdateSessionProgress();
        
        Console.WriteLine($"DEBUG: AI analysis phase completed");
    }
    
    private async Task RunSessionAIAnalysis()
    {
        if (selectedSession == null) return;

        Console.WriteLine($"DEBUG: Starting session-level AI analysis for {selectedSession.MovieTitle}");
        
        // Check that ALL processable files are ready for AI analysis
        var allFiles = selectedSession.AudioFiles.ToList();
        var failedFiles = allFiles.Where(f => f.ProcessingStatus == AudioProcessingStatus.Failed).ToList();
        var processableFiles = allFiles.Where(f => f.ProcessingStatus != AudioProcessingStatus.Failed).ToList();
        var filesReadyForAI = processableFiles.Where(f => 
            f.ProcessingStatus >= AudioProcessingStatus.TranscriptionComplete).ToList();
        var filesNotReady = processableFiles.Where(f => 
            f.ProcessingStatus < AudioProcessingStatus.TranscriptionComplete).ToList();

        Console.WriteLine($"DEBUG: File status check - Total: {allFiles.Count}, Failed: {failedFiles.Count}, Processable: {processableFiles.Count}, Ready for AI: {filesReadyForAI.Count}, Not Ready: {filesNotReady.Count}");

        if (filesNotReady.Any())
        {
            var notReadyInfo = string.Join(", ", filesNotReady.Select(f => $"{f.FileName}({f.ProcessingStatus})"));
            throw new Exception($"Cannot run AI analysis yet. {filesNotReady.Count} files are still processing: {notReadyInfo}. Please wait for all files to complete transcription.");
        }

        if (!filesReadyForAI.Any())
        {
            throw new Exception("No files are ready for AI analysis. Please complete transcription first.");
        }

        // Check that we have actual transcript content
        var filesWithTranscripts = filesReadyForAI.Where(f => !string.IsNullOrEmpty(f.TranscriptText)).ToList();
        if (!filesWithTranscripts.Any())
        {
            throw new Exception("No transcript content available for AI analysis. Transcription may have failed.");
        }

        Console.WriteLine($"DEBUG: All {processableFiles.Count} processable files are ready. Found {filesWithTranscripts.Count} files with transcript content for analysis");

        // Update all eligible files to show AI processing status
        var eligibleFiles = selectedSession.AudioFiles.Where(f => 
            f.ProcessingStatus >= AudioProcessingStatus.TranscriptionComplete || 
            f.ProcessingStatus == AudioProcessingStatus.Complete).ToList();

        foreach (var file in eligibleFiles)
        {
            file.ProcessingStatus = AudioProcessingStatus.ProcessingWithAI;
            file.CurrentStep = "Running AI analysis";
            file.ProgressPercentage = 20;
            file.CanRetry = false;
            file.ConversionError = string.Empty;
        }

        await MongoDbService.UpsertAsync(selectedSession);
        await InvokeAsync(StateHasChanged);

        try
        {
            // Update progress
            foreach (var file in eligibleFiles)
            {
                file.CurrentStep = "Analyzing conversation";
                file.ProgressPercentage = 50;
            }
            await MongoDbService.UpsertAsync(selectedSession);
            await InvokeAsync(StateHasChanged);

            // Run the actual AI analysis - this analyzes ALL transcripts together
            var categoryResults = await AnalysisService.AnalyzeSessionAsync(selectedSession);
            selectedSession.CategoryResults = categoryResults;
            selectedSession.SessionStats = AnalysisService.GenerateSessionStats(selectedSession, categoryResults);
            
            // Update progress
            foreach (var file in eligibleFiles)
            {
                file.CurrentStep = "AI analysis complete";
                file.ProgressPercentage = 90;
            }
            await MongoDbService.UpsertAsync(selectedSession);
            await InvokeAsync(StateHasChanged);

            // Mark all eligible files as complete
            foreach (var file in eligibleFiles)
            {
                file.ProcessingStatus = AudioProcessingStatus.Complete;
                file.CurrentStep = "Processing complete";
                file.ProgressPercentage = 100;
                file.ProcessedAt = DateTime.UtcNow;
                file.CanRetry = true;
            }

            // Mark the entire session as complete
            selectedSession.Status = ProcessingStatus.Complete;
            selectedSession.ProcessedAt = DateTime.UtcNow;

            Console.WriteLine($"DEBUG: Session AI analysis completed successfully - updated {eligibleFiles.Count} files to Complete status and marked session as Complete");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"DEBUG: Session AI analysis failed: {ex.Message}");
            
            // Mark all files as failed
            foreach (var file in eligibleFiles)
            {
                file.ProcessingStatus = AudioProcessingStatus.Failed;
                file.ConversionError = ex.Message;
                file.CurrentStep = "AI analysis failed";
                file.CanRetry = true;
            }
            
            throw; // Re-throw to be handled by calling method
        }
        finally
        {
            await MongoDbService.UpsertAsync(selectedSession);
            await InvokeAsync(StateHasChanged);
            await UpdateSessionProgress();
        }
    }

    private AudioProcessingStatus? DetermineStartingStatus(AudioFile file, AudioProcessingStatus requestedStatus)
    {
        // Never process failed files unless specifically requesting to retry from the beginning
        if (file.ProcessingStatus == AudioProcessingStatus.Failed && requestedStatus != AudioProcessingStatus.ConvertingToMp3)
        {
            return null;
        }
        
        // Determine if this file should be included based on user request
        return requestedStatus switch
        {
            // MP3 Conversion: Include all files (including complete ones - user wants to restart)
            AudioProcessingStatus.ConvertingToMp3 => AudioProcessingStatus.ConvertingToMp3,
                
            // Gladia Upload: Include files that have MP3s or can be converted to MP3
            AudioProcessingStatus.UploadingToGladia => 
                file.ProcessingStatus >= AudioProcessingStatus.ProcessedMp3 || file.ProcessingStatus == AudioProcessingStatus.Complete 
                    ? AudioProcessingStatus.UploadingToGladia : null,
                
            // Transcription: Include files that can reach transcription (have been uploaded or are complete)
            AudioProcessingStatus.Transcribing => 
                file.ProcessingStatus >= AudioProcessingStatus.UploadedToGladia || file.ProcessingStatus == AudioProcessingStatus.Complete
                    ? AudioProcessingStatus.Transcribing : null,
                
            // AI Analysis: Include files that have transcripts or are complete (allow re-running AI analysis)
            AudioProcessingStatus.ProcessingWithAI => 
                file.ProcessingStatus >= AudioProcessingStatus.TranscriptionComplete || file.ProcessingStatus == AudioProcessingStatus.Complete
                    ? AudioProcessingStatus.ProcessingWithAI : null,
                
            _ => AudioProcessingStatus.ConvertingToMp3
        };
    }

    // Helper methods for UI
    private string GetRowClass(AudioProcessingStatus status) => status switch
    {
        AudioProcessingStatus.Failed => "table-danger",
        AudioProcessingStatus.Complete => "table-success",
        _ when IsInProgress(status) => "table-warning",
        _ => ""
    };

    private string GetStatusBadgeClass(AudioProcessingStatus status) => status switch
    {
        AudioProcessingStatus.Failed => "bg-danger",
        AudioProcessingStatus.Complete => "bg-success",
        _ when IsInProgress(status) => "bg-warning",
        _ => "bg-secondary"
    };

    private string GetProgressBarClass(AudioProcessingStatus status) => status switch
    {
        AudioProcessingStatus.Failed => "bg-danger",
        AudioProcessingStatus.Complete => "bg-success",
        _ when IsInProgress(status) => "progress-bar-striped progress-bar-animated",
        _ => ""
    };

    private string GetStatusIcon(AudioProcessingStatus status) => status switch
    {
        AudioProcessingStatus.Pending => "â³",
        AudioProcessingStatus.Uploading => "ðŸ“¤",
        AudioProcessingStatus.ConvertingToMp3 => "ðŸ”„",
        AudioProcessingStatus.PendingMp3 => "â¸ï¸",
        AudioProcessingStatus.FailedMp3 => "âŒ",
        AudioProcessingStatus.ProcessedMp3 => "ðŸ”§",
        AudioProcessingStatus.UploadingToGladia => "â¬†ï¸",
        AudioProcessingStatus.UploadedToGladia => "â˜ï¸",
        AudioProcessingStatus.Transcribing => "ðŸŽ¤",
        AudioProcessingStatus.TranscriptionComplete => "ðŸ“",
        AudioProcessingStatus.ProcessingWithAI => "ðŸ¤–",
        AudioProcessingStatus.Complete => "âœ…",
        AudioProcessingStatus.Failed => "âŒ",
        _ => "â“"
    };

    private string GetStatusText(AudioProcessingStatus status) => status switch
    {
        AudioProcessingStatus.Pending => "Ready to process",
        AudioProcessingStatus.Uploading => "Uploading file",
        AudioProcessingStatus.ConvertingToMp3 => "Converting to MP3",
        AudioProcessingStatus.PendingMp3 => "MP3 ready for upload",
        AudioProcessingStatus.FailedMp3 => "MP3 conversion failed",
        AudioProcessingStatus.ProcessedMp3 => "MP3 processed",
        AudioProcessingStatus.UploadingToGladia => "Uploading to Gladia",
        AudioProcessingStatus.UploadedToGladia => "Uploaded to Gladia",
        AudioProcessingStatus.Transcribing => "Transcribing audio",
        AudioProcessingStatus.TranscriptionComplete => "Transcription complete",
        AudioProcessingStatus.ProcessingWithAI => "Processing with AI",
        AudioProcessingStatus.Complete => "Complete",
        AudioProcessingStatus.Failed => "Failed",
        _ => $"Unknown status: {status}"
    };

    private bool IsInProgress(AudioProcessingStatus status) => status is 
        AudioProcessingStatus.Uploading or
        AudioProcessingStatus.ConvertingToMp3 or 
        AudioProcessingStatus.UploadingToGladia or 
        AudioProcessingStatus.Transcribing or 
        AudioProcessingStatus.ProcessingWithAI;

    private int GetOverallProgress()
    {
        if (selectedSession?.AudioFiles.Any() != true) return 0;
        
        var totalFiles = selectedSession.AudioFiles.Count;
        var totalSteps = totalFiles * 5; // 5 steps per file: Upload, Convert, Upload to Gladia, Transcribe, AI Process
        var completedSteps = 0;
        
        foreach (var file in selectedSession.AudioFiles)
        {
            completedSteps += file.ProcessingStatus switch
            {
                AudioProcessingStatus.Pending => 0,
                AudioProcessingStatus.Uploading => 0,
                AudioProcessingStatus.ConvertingToMp3 => 1,
                AudioProcessingStatus.PendingMp3 or AudioProcessingStatus.ProcessedMp3 => 2,
                AudioProcessingStatus.UploadingToGladia => 2,
                AudioProcessingStatus.UploadedToGladia => 3,
                AudioProcessingStatus.Transcribing => 3,
                AudioProcessingStatus.TranscriptionComplete => 4,
                AudioProcessingStatus.ProcessingWithAI => 4,
                AudioProcessingStatus.Complete => 5,
                AudioProcessingStatus.Failed or AudioProcessingStatus.FailedMp3 => (int)(file.ProgressPercentage / 20), // Partial credit
                _ => 0
            };
        }
        
        return (int)((double)completedSteps / totalSteps * 100);
    }
    
    private async Task UpdateSessionProgress()
    {
        // Force UI update with new session progress
        await InvokeAsync(StateHasChanged);
    }

    private bool IsAudioFile(string fileName)
    {
        var allowedExtensions = new[] { ".mp3", ".wav", ".ogg", ".flac", ".aac", ".m4a", ".wma", ".mp4", ".mov", ".avi", ".mkv", ".webm", ".m4v", ".3gp" };
        return allowedExtensions.Contains(Path.GetExtension(fileName).ToLowerInvariant());
    }

    private string GetActionButtonText(AudioProcessingStatus status) => status switch
    {
        AudioProcessingStatus.Pending => "Start",
        AudioProcessingStatus.Failed => "Retry",
        AudioProcessingStatus.Complete => "Redo",
        _ => "Process"
    };

    private bool CanStartStep(AudioFile file, AudioProcessingStatus targetStatus) => targetStatus switch
    {
        AudioProcessingStatus.ConvertingToMp3 => true, // Can always convert
        AudioProcessingStatus.UploadingToGladia => file.ProcessingStatus >= AudioProcessingStatus.ProcessedMp3 || file.ProcessingStatus == AudioProcessingStatus.FailedMp3,
        AudioProcessingStatus.Transcribing => file.ProcessingStatus >= AudioProcessingStatus.UploadedToGladia,
        AudioProcessingStatus.ProcessingWithAI => file.ProcessingStatus >= AudioProcessingStatus.TranscriptionComplete || file.ProcessingStatus == AudioProcessingStatus.Complete,
        _ => false
    };

    private async Task StartFullProcessing(AudioFile file)
    {
        file.ProcessingStatus = AudioProcessingStatus.Pending;
        file.ProgressPercentage = 0;
        file.CurrentStep = "Restarting full processing workflow";
        file.LastUpdated = DateTime.UtcNow;
        file.CanRetry = false;
        file.ConversionError = string.Empty;

        await StartProcess(file, AudioProcessingStatus.ConvertingToMp3);
    }

    private async Task RerunAIAnalysis(AudioFile file)
    {
        Console.WriteLine($"DEBUG: Starting AI analysis rerun for {file.FileName}");
        
        // Ensure we have a transcript to analyze
        if (string.IsNullOrEmpty(file.TranscriptText))
        {
            Console.WriteLine($"DEBUG: No transcript available for {file.FileName}, cannot run AI analysis");
            file.ProcessingStatus = AudioProcessingStatus.Failed;
            file.ConversionError = "No transcript available for AI analysis";
            file.CurrentStep = "AI analysis failed - no transcript";
            await MongoDbService.UpsertAsync(selectedSession!);
            await InvokeAsync(StateHasChanged);
            return;
        }

        // Reset to TranscriptionComplete status and then run AI processing
        file.ProcessingStatus = AudioProcessingStatus.TranscriptionComplete;
        file.ProgressPercentage = 100;
        file.CurrentStep = "Ready for AI analysis";
        file.LastUpdated = DateTime.UtcNow;
        file.CanRetry = false;
        file.ConversionError = string.Empty;

        await MongoDbService.UpsertAsync(selectedSession!);
        await InvokeAsync(StateHasChanged);

        Console.WriteLine($"DEBUG: Starting AI processing for {file.FileName}");
        await StartProcess(file, AudioProcessingStatus.ProcessingWithAI);
    }

    private string FormatBytes(long bytes)
    {
        string[] suffixes = { "B", "KB", "MB", "GB", "TB" };
        int counter = 0;
        decimal number = bytes;
        while (Math.Round(number / 1024) >= 1)
        {
            number /= 1024;
            counter++;
        }
        return string.Format("{0:n1} {1}", number, suffixes[counter]);
    }

    private string GetStartButtonTooltip()
    {
        if (isProcessing) return "Processing in progress...";
        if (!selectedMovieId.HasValue) return "Please select a movie";
        if (!selectedFiles.Any()) return "Please upload audio files";
        if (!presentSpeakers.Any()) return "Please assign speakers";
        return "Start processing audio files";
    }

    private string GetSessionState()
    {
        return $"Movie: {selectedMovieId.HasValue}, Files: {selectedFiles.Count}, Speakers: {presentSpeakers.Count}";
    }

    private string GetSessionStatusBadgeClass(ProcessingStatus status) => status switch
    {
        ProcessingStatus.Pending => "bg-secondary",
        ProcessingStatus.Validating => "bg-info", 
        ProcessingStatus.Transcribing => "bg-primary",
        ProcessingStatus.Analyzing => "bg-warning",
        ProcessingStatus.Complete => "bg-success",
        ProcessingStatus.Failed => "bg-danger",
        _ => "bg-secondary"
    };

    /// <summary>
    /// Detects and renames master recording files based on patterns from the old system
    /// Replicates the logic from MovieSessionService.ScanAudioFiles
    /// </summary>
    private async Task DetectAndRenameMasterRecording(MovieSession session)
    {
        var identifiedFiles = new HashSet<string>();

        foreach (var audioFile in session.AudioFiles)
        {
            var fileName = audioFile.FileName;
            var fileNameUpper = fileName.ToUpper();

            // Check for MIC1-9 pattern (convert 1-based file naming to 0-based speaker numbers)
            var micMatch = Regex.Match(fileNameUpper, @"^MIC(\d)\.WAV$");
            if (micMatch.Success)
            {
                var micFileNumber = int.Parse(micMatch.Groups[1].Value); // 1-based from file
                audioFile.SpeakerNumber = micFileNumber - 1; // Convert to 0-based for consistency
                identifiedFiles.Add(fileName);
                Console.WriteLine($"DEBUG: Detected microphone file: {fileName} as MIC{micFileNumber} (Speaker {audioFile.SpeakerNumber})");
            }
            // Check for existing speaker pattern (convert 1-based file naming to 0-based speaker numbers)
            else if (Regex.IsMatch(fileName, @"^(\d)_Speaker\d", RegexOptions.IgnoreCase))
            {
                var match = Regex.Match(fileName, @"^(\d)_Speaker\d", RegexOptions.IgnoreCase);
                var speakerFileNumber = int.Parse(match.Groups[1].Value); // 1-based from file
                audioFile.SpeakerNumber = speakerFileNumber - 1; // Convert to 0-based for consistency
                identifiedFiles.Add(fileName);
            }
            // Skip PHONE.WAV and SOUND_PAD.WAV files (they're not speakers)
            else if (fileNameUpper == "PHONE.WAV" || fileNameUpper == "SOUND_PAD.WAV" || fileNameUpper == "SOUNDPAD.WAV")
            {
                identifiedFiles.Add(fileName);
                Console.WriteLine($"DEBUG: Identified {(fileNameUpper.Contains("PHONE") ? "phone" : "sound pad")} file: {fileName}");
            }
            // Check for master recording with timestamp pattern (e.g., 2024_1122_1839.wav)
            else if (Regex.IsMatch(fileName, @"^\d{4}_\d{4}_\d{4}\.(wav|mp3|m4a|aac|ogg|flac)$", RegexOptions.IgnoreCase))
            {
                audioFile.IsMasterRecording = true;
                identifiedFiles.Add(fileName);
                Console.WriteLine($"DEBUG: Identified timestamped master mix file: {fileName}");
            }
            // Check for master recording patterns
            else if (fileName.ToLower().Contains("master") ||
                     fileName.ToLower().Contains("combined") ||
                     fileName.ToLower().Contains("full") ||
                     fileName.ToLower().Contains("group"))
            {
                audioFile.IsMasterRecording = true;
                identifiedFiles.Add(fileName);
            }
        }

        // Any unidentified file is likely the master mix (critical file)
        var unidentifiedFiles = session.AudioFiles.Where(f => !identifiedFiles.Contains(f.FileName)).ToList();
        if (unidentifiedFiles.Count == 1)
        {
            unidentifiedFiles[0].IsMasterRecording = true;
            Console.WriteLine($"DEBUG: Identified master mix file by elimination: {unidentifiedFiles[0].FileName}");
        }
        else if (unidentifiedFiles.Count > 1)
        {
            // If multiple unidentified files, pick the largest as master mix
            var largestFile = unidentifiedFiles.OrderByDescending(f => f.FileSize).First();
            largestFile.IsMasterRecording = true;
            Console.WriteLine($"DEBUG: Multiple unidentified files. Selected {largestFile.FileName} as master mix based on size");
        }

        // Rename master recording to MASTER_MIX with original extension preserved
        var masterFile = session.AudioFiles.FirstOrDefault(f => f.IsMasterRecording);
        if (masterFile != null && !masterFile.FileName.StartsWith("MASTER_MIX", StringComparison.OrdinalIgnoreCase))
        {
            var oldPath = masterFile.FilePath;
            var directory = Path.GetDirectoryName(oldPath);
            var originalExtension = Path.GetExtension(oldPath);
            var newFileName = $"MASTER_MIX{originalExtension}";
            var newPath = Path.Combine(directory!, newFileName);

            try
            {
                // If MASTER_MIX file already exists with this extension, don't overwrite
                if (!File.Exists(newPath))
                {
                    File.Move(oldPath, newPath);
                    masterFile.FileName = newFileName;
                    masterFile.FilePath = newPath;
                    Console.WriteLine($"DEBUG: Renamed master mix file from {Path.GetFileName(oldPath)} to {newFileName}");
                }
                else
                {
                    Console.WriteLine($"DEBUG: {newFileName} already exists, keeping original file name: {masterFile.FileName}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DEBUG ERROR: Failed to rename master mix file from {masterFile.FileName} to {newFileName}: {ex.Message}");
            }
        }

        // Log warning if no master recording found
        if (!session.AudioFiles.Any(f => f.IsMasterRecording))
        {
            Console.WriteLine($"DEBUG ERROR: CRITICAL: No master mix file identified in session {session.Id}");
        }
    }

    /// <summary>
    /// Analyzes audio files to determine participants based on speaker assignments
    /// </summary>
    private void AnalyzeAudioFiles(MovieSession session)
    {
        // Based on audio files, determine who was present (using zero-based speaker numbers)
        var presentSpeakers = session.AudioFiles
            .Where(f => f.SpeakerNumber.HasValue)
            .Select(f => f.SpeakerNumber!.Value)
            .Distinct()
            .OrderBy(x => x)
            .ToList();

        // All possible speakers (0-8) - supports up to 9 microphones (zero-based)
        var allSpeakers = Enumerable.Range(0, 9).ToList();
        var absentSpeakers = allSpeakers.Except(presentSpeakers).ToList();

        // Use mic assignments if available, otherwise show generic mic labels
        session.ParticipantsPresent = presentSpeakers.Select(mic =>
            session.MicAssignments.TryGetValue(mic, out var name) && !string.IsNullOrEmpty(name)
                ? name
                : $"Mic {mic + 1}" // Convert to 1-based for display
        ).ToList();

        session.ParticipantsAbsent = absentSpeakers.Select(mic =>
            session.MicAssignments.TryGetValue(mic, out var name) && !string.IsNullOrEmpty(name)
                ? name
                : $"Mic {mic + 1}" // Convert to 1-based for display
        ).ToList();
    }

    private async Task ResumeInProgressTranscriptions()
    {
        if (selectedSession?.AudioFiles == null) return;
        
        var transcribingFiles = selectedSession.AudioFiles.Where(f => 
            f.ProcessingStatus == AudioProcessingStatus.Transcribing && 
            !string.IsNullOrEmpty(f.TranscriptId)).ToList();
            
        if (transcribingFiles.Any())
        {
            Console.WriteLine($"DEBUG: Found {transcribingFiles.Count} files in transcription progress, resuming monitoring");
            
            // Update UI to show transcribing status
            foreach (var file in transcribingFiles)
            {
                file.CurrentStep = "Transcription in progress (resumed)";
                file.ProgressPercentage = 50; // Set a middle progress value
            }
            
            await InvokeAsync(StateHasChanged);
            
            // Start timer to check transcription status
            StartTranscriptionStatusTimer();
        }
    }
    
    private void StartTranscriptionStatusTimer()
    {
        // Stop existing timer if any
        transcriptionStatusTimer?.Dispose();
        
        // Check every 10 seconds
        transcriptionStatusTimer = new Timer(async _ => await CheckTranscriptionStatus(), 
            null, TimeSpan.Zero, TimeSpan.FromSeconds(10));
        
        Console.WriteLine("DEBUG: Started transcription status monitoring timer");
    }
    
    private void StopTranscriptionStatusTimer()
    {
        transcriptionStatusTimer?.Dispose();
        transcriptionStatusTimer = null;
        Console.WriteLine("DEBUG: Stopped transcription status monitoring timer");
    }
    
    private async Task CheckTranscriptionStatus()
    {
        if (selectedSession?.AudioFiles == null) return;
        
        var transcribingFiles = selectedSession.AudioFiles.Where(f => 
            f.ProcessingStatus == AudioProcessingStatus.Transcribing && 
            !string.IsNullOrEmpty(f.TranscriptId)).ToList();
            
        if (!transcribingFiles.Any())
        {
            StopTranscriptionStatusTimer();
            return;
        }
        
        Console.WriteLine($"DEBUG: Checking transcription status for {transcribingFiles.Count} files");
        
        bool anyUpdated = false;
        
        foreach (var file in transcribingFiles)
        {
            try
            {
                var result = await GladiaService.GetTranscriptionResultAsync(file.TranscriptId!);
                
                if (result.status == "done")
                {
                    Console.WriteLine($"DEBUG: Transcription completed for {file.FileName}");
                    
                    // Build transcript from utterances with proper speaker mapping
                    file.TranscriptText = selectedSession.MicAssignments != null && selectedSession.MicAssignments.Any()
                        ? GladiaService.BuildTranscriptFromUtterances(result, selectedSession.MicAssignments, file.FileName)
                        : result.result?.transcription?.full_transcript ?? string.Empty;
                    
                    file.ProcessingStatus = AudioProcessingStatus.TranscriptionComplete;
                    file.CurrentStep = "Transcription complete";
                    file.ProgressPercentage = 100;
                    file.ProcessedAt = DateTime.UtcNow;
                    
                    anyUpdated = true;
                    
                    // Save transcription JSON
                    try
                    {
                        var jsonPath = await GladiaService.SaveTranscriptionJsonAsync(result, file.FilePath, selectedSession.FolderPath);
                        file.JsonFilePath = jsonPath;
                    }
                    catch (Exception jsonEx)
                    {
                        Console.WriteLine($"DEBUG: Failed to save transcription JSON for {file.FileName}: {jsonEx.Message}");
                    }
                    
                    // After transcription completes, automatically start AI processing
                    Console.WriteLine($"DEBUG: Starting AI processing for {file.FileName}");
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            await StartProcess(file, AudioProcessingStatus.ProcessingWithAI);
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"DEBUG: Failed to start AI processing for {file.FileName}: {ex.Message}");
                        }
                    });
                }
                else if (result.status == "error")
                {
                    Console.WriteLine($"DEBUG: Transcription failed for {file.FileName}: {result.error?.message}");
                    
                    file.ProcessingStatus = AudioProcessingStatus.Failed;
                    file.ConversionError = result.error?.message ?? "Transcription failed";
                    file.CurrentStep = "Transcription failed";
                    file.CanRetry = true;
                    
                    anyUpdated = true;
                }
                else
                {
                    // Still in progress - update progress indicator
                    var progress = result.status switch
                    {
                        "queued" => 20,
                        "processing" => 60,
                        _ => 50
                    };
                    
                    if (file.ProgressPercentage != progress)
                    {
                        file.ProgressPercentage = progress;
                        file.CurrentStep = $"Transcription {result.status}";
                        anyUpdated = true;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DEBUG: Error checking transcription status for {file.FileName}: {ex.Message}");
                // Don't mark as failed on temporary errors, keep checking
            }
        }
        
        if (anyUpdated)
        {
            await MongoDbService.UpsertAsync(selectedSession);
            await InvokeAsync(StateHasChanged);
            await UpdateSessionProgress();
        }
        
        // Check if all transcriptions are done
        var stillTranscribing = selectedSession.AudioFiles.Any(f => f.ProcessingStatus == AudioProcessingStatus.Transcribing);
        if (!stillTranscribing)
        {
            Console.WriteLine("DEBUG: All transcriptions completed, stopping monitoring");
            StopTranscriptionStatusTimer();
        }
    }

    public void Dispose()
    {
        transcriptionStatusTimer?.Dispose();
    }
}