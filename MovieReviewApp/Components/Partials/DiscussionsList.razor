@page "/discussions/list"
@using System.IO
@using System.Text.Json
@inject IWebHostEnvironment WebHostEnvironment
@inject HttpClient Http
@inject IConfiguration Configuration;

<h3>Processed Files</h3>

@if (Folders == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div class="mb-3">
        <label for="folderSelect" class="form-label">Select Folder:</label>
        <select id="folderSelect" class="form-select" @onchange="OnFolderSelected">
            <option value="">Choose a folder...</option>
            @foreach (var folder in Folders)
            {
                <option value="@folder">@folder.Replace("-", " ")</option>
            }
        </select>
    </div>

    @if (!string.IsNullOrEmpty(SelectedFolder))
    {
        <div class="d-flex justify-content-between">
            <h4>Files for @SelectedFolder.Replace("-", " ")</h4>
            <button @onclick="GuessNames" class="btn btn-secondary">Guess Names</button>
        </div>

        <table class="table table-striped">
            <thead>
                <tr>
                    <th>File Name</th>
                    <th>Type</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var file in Files)
                {
                    <tr>
                        <td>@file.Name</td>
                        <td>@file.Extension</td>
                        <td>
                            @if (file.Extension.Equals(".txt", StringComparison.OrdinalIgnoreCase))
                            {
                                <button @onclick="() => ViewTextFile(file.FullName)" class="btn btn-primary">View</button>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
}

@if (!string.IsNullOrEmpty(TextFileContent))
{
    <div class="mt-4">
        <h4>File Content</h4>
        <pre>@TextFileContent</pre>
    </div>
}

@code {
    private List<string> Folders { get; set; }
    private List<FileInfo> Files { get; set; } = new List<FileInfo>();
    private string SelectedFolder { get; set; }
    private string TextFileContent { get; set; }
    private string _apiKey { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await LoadFolders();
        try
        {
            _apiKey = Configuration["OpenAI:ApiKey"];
        }
        catch (Exception ex)
        {
        }
    }

    private Task LoadFolders()
    {
        var uploadsPath = Path.Combine(WebHostEnvironment.WebRootPath, "uploads");
        Folders = Directory.GetDirectories(uploadsPath)
                           .Select(Path.GetFileName)
                           .ToList();
        return Task.CompletedTask;
    }

    private void OnFolderSelected(ChangeEventArgs e)
    {
        SelectedFolder = e.Value.ToString();
        if (!string.IsNullOrEmpty(SelectedFolder))
        {
            LoadFiles(SelectedFolder);
        }
        else
        {
            Files.Clear();
        }
        TextFileContent = string.Empty;
    }

    private void LoadFiles(string folderName)
    {
        var folderPath = Path.Combine(WebHostEnvironment.WebRootPath, "uploads", folderName);
        Files = Directory.GetFiles(folderPath)
                         .Where(f =>
                                     Path.GetExtension(f).Equals(".txt", StringComparison.OrdinalIgnoreCase))
                         .Select(f => new FileInfo(f))
                         .ToList();
    }

    private async Task ViewTextFile(string filePath)
    {
        TextFileContent = await File.ReadAllTextAsync(filePath);
    }

    private async Task GuessNames()
    {
        try
        {
            var folderPath = Path.Combine(WebHostEnvironment.WebRootPath, "uploads", SelectedFolder);
            var textFiles = Directory.GetFiles(folderPath, "*.txt");

            // Prepare content for API by separating each file and treating them as different contexts
            var fileContents = textFiles.Select(File.ReadAllText).ToArray();

            // Prepare a prompt for each file, treating each file as a different context
            var prompt = "There are six people in this conversation: Jared, Lacey, Keri, Dave, Jeremiah, Nikki. " +
                         "Each file represents a separate conversation, and the speakers (e.g., 'Speaker A', 'Speaker B') " +
                         "may represent different people across files, but they are always one of the six people mentioned. " +
                         "Please replace the 'Speaker A', 'Speaker B', etc. with the most appropriate name in each file.\n\n";

            for (int i = 0; i < fileContents.Length; i++)
            {
                prompt += $"File {i + 1} content:\n{fileContents[i]}\n\n";
            }

            var request = new
            {
                model = "gpt-4o",  // Using the GPT-4o model as specified
                messages = new[]
                {
                new { role = "system", content = "You are an assistant that helps identify speakers in conversations." },
                new { role = "user", content = prompt }
            }
            };

            // Use the _apiKey variable for authentication
            Http.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", _apiKey);
            var response = await Http.PostAsJsonAsync("https://api.openai.com/v1/chat/completions", request);

            if (response.IsSuccessStatusCode)
            {
                var responseBody = await response.Content.ReadAsStringAsync();

                using (JsonDocument doc = JsonDocument.Parse(responseBody))
                {
                    var root = doc.RootElement;

                    // Navigate through the JSON structure to extract 'choices' and 'message.content'
                    var choices = root.GetProperty("choices");
                    var messageContent = choices[0].GetProperty("message").GetProperty("content").GetString();

                    // Here, we do not split by 'File X content', instead we apply guessed names directly to the content
                    for (int i = 0; i < textFiles.Length; i++)
                    {
                        var fileContent = File.ReadAllText(textFiles[i]);
                        var updatedContent = ApplyGuessedNames(fileContent, messageContent);
                        File.WriteAllText(textFiles[i], updatedContent);
                    }
                }
            }
            else
            {
                // Handle API failure
                Console.WriteLine("API request failed.");
            }
        }
        catch (Exception ex)
        {
            // Log or handle exceptions
            Console.WriteLine($"An error occurred: {ex.Message}");
        }
    }

    // Helper function to apply guessed names directly into the content
    private string ApplyGuessedNames(string fileContent, string messageContent)
    {
        // Replace speaker placeholders (Speaker A, Speaker B, etc.) with guessed names from messageContent
        // Assume the format is "Speaker A: Jared", "Speaker B: Lacey", etc.
        var speakerMap = new Dictionary<string, string>();

        // Parse the messageContent to extract the speaker mappings
        var lines = messageContent.Split('\n');
        foreach (var line in lines)
        {
            // Parse lines that look like "Jared: Some dialogue"
            var parts = line.Split(':');
            if (parts.Length == 2)
            {
                var speakerName = parts[0].Trim();
                var dialogue = parts[1].Trim();
                // Add the speaker and their dialogue to the map if it's a known person
                if (!speakerMap.ContainsKey(speakerName) &&
                    new[] { "Jared", "Lacey", "Keri", "Dave", "Jeremiah", "Nikki" }.Contains(speakerName))
                {
                    speakerMap[speakerName] = dialogue;
                }
            }
        }

        // Now replace any placeholders (like "Speaker A") in the original fileContent with the actual speaker names
        foreach (var speaker in speakerMap)
        {
            fileContent = fileContent.Replace(speaker.Key, speaker.Value);
        }

        return fileContent;
    }

    // Helper function to replace placeholders with guessed names per file
    private string ReplaceSpeakerPlaceholders(string fileContent, string guessedNamesForFile)
    {
        // Parse the guessed names from the format and build a speaker map
        var speakerMap = new Dictionary<string, string>();
        var lines = guessedNamesForFile.Split('\n');

        foreach (var line in lines)
        {
            // Parse lines that look like '**Speaker A:** Jared'
            if (line.Contains("**Speaker"))
            {
                var parts = line.Split(':');
                if (parts.Length == 2)
                {
                    var placeholder = parts[0].Replace("**", "").Trim(); // e.g., "Speaker A"
                    var realName = parts[1].Trim();                      // e.g., "Jared"
                    speakerMap[placeholder] = realName;
                }
            }
        }

        // Replace placeholders in the file content based on the guessed names
        foreach (var speaker in speakerMap)
        {
            fileContent = fileContent.Replace(speaker.Key, speaker.Value);
        }

        return fileContent;
    }

}
