@page "/discussions/list"
@using System.IO
@using System.Text.Json
@using System.Text.RegularExpressions
@inject IWebHostEnvironment WebHostEnvironment
@inject HttpClient Http
@inject IConfiguration Configuration

<h3>Processed Files</h3>

@if (!string.IsNullOrEmpty(ErrorMessage))
{
    <div class="alert alert-danger" role="alert">
        @ErrorMessage
    </div>
}

@if (Folders == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div class="mb-3">
        <label for="folderSelect" class="form-label">Select Folder:</label>
        <select id="folderSelect" class="form-select" @onchange="OnFolderSelected">
            <option value="">Choose a folder...</option>
            @foreach (var folder in Folders)
            {
                <option value="@folder">@folder.Replace("-", " ")</option>
            }
        </select>
    </div>

    @if (!string.IsNullOrEmpty(SelectedFolder))
    {
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h4>Files for @SelectedFolder.Replace("-", " ")</h4>
            <button @onclick="GuessNames" class="btn btn-secondary" disabled="@IsProcessing">Guess Names</button>
        </div>

        @if (IsProcessing)
        {
            <div class="progress mb-3">
                <div class="progress-bar" role="progressbar" style="width: @($"{ProgressPercentage}%");" aria-valuenow="@ProgressPercentage" aria-valuemin="0" aria-valuemax="100">@($"{ProgressPercentage}%")</div>
            </div>
            <p class="text-muted">@StatusMessage</p>
        }

        <table class="table table-striped">
            <thead>
                <tr>
                    <th>File Name</th>
                    <th>Type</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var file in Files)
                {
                    <tr>
                        <td>@file.Name</td>
                        <td>@file.Extension</td>
                        <td>
                            @if (file.Extension.Equals(".txt", StringComparison.OrdinalIgnoreCase))
                            {
                                <button @onclick="() => ViewTextFile(file.FullName)" class="btn btn-primary">View</button>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
}

@if (!string.IsNullOrEmpty(TextFileContent))
{
    <div class="mt-4">
        <h4>File Content</h4>
        <pre>@TextFileContent</pre>
    </div>
}

@code {
    private List<string> Folders { get; set; } = new List<string>();
    private List<FileInfo> Files { get; set; } = new List<FileInfo>();
    private string SelectedFolder { get; set; } = "";
    private string TextFileContent { get; set; } = "";
    private string _apiKey { get; set; } = "";
    private string ErrorMessage { get; set; } = "";
    private bool IsProcessing { get; set; }
    private int ProgressPercentage { get; set; }
    private string StatusMessage { get; set; } = "";

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadFolders();
            _apiKey = Configuration["OpenAI:ApiKey"];
            if (string.IsNullOrEmpty(_apiKey))
            {
                ErrorMessage = "API key not found in configuration.";
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error initializing: {ex.Message}";
        }
    }

    private async Task LoadFolders()
    {
        try
        {
            StatusMessage = "Loading folders...";
            IsProcessing = true;
            ProgressPercentage = 0;
            StateHasChanged();

            var uploadsPath = Path.Combine(WebHostEnvironment.WebRootPath, "uploads");
            Directory.CreateDirectory(uploadsPath);
            Folders = Directory.GetDirectories(uploadsPath)
                               .Select(Path.GetFileName)
                               .Where(x => x.IndexOf("_") == -1)
                               .ToList();

            ProgressPercentage = 100;
            StatusMessage = "Folders loaded successfully.";
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error loading folders: {ex.Message}";
        }
        finally
        {
            IsProcessing = false;
            StateHasChanged();
        }
    }

    private async Task OnFolderSelected(ChangeEventArgs e)
    {
        try
        {
            SelectedFolder = e.Value.ToString();
            if (!string.IsNullOrEmpty(SelectedFolder))
            {
                await LoadFiles(SelectedFolder);
            }
            else
            {
                Files.Clear();
            }
            TextFileContent = string.Empty;
            ErrorMessage = string.Empty;
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error selecting folder: {ex.Message}";
        }
    }

    private async Task LoadFiles(string folderName)
    {
        try
        {
            StatusMessage = "Loading files...";
            IsProcessing = true;
            ProgressPercentage = 0;
            StateHasChanged();

            var folderPath = Path.Combine(WebHostEnvironment.WebRootPath, "uploads", folderName);
            Files = Directory.GetFiles(folderPath)
                             .Where(f => Path.GetExtension(f).Equals(".txt", StringComparison.OrdinalIgnoreCase))
                             .Select(f => new FileInfo(f))
                             .ToList();

            ProgressPercentage = 100;
            StatusMessage = "Files loaded successfully.";
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error loading files: {ex.Message}";
        }
        finally
        {
            IsProcessing = false;
            StateHasChanged();
        }
    }

    private async Task ViewTextFile(string filePath)
    {
        try
        {
            TextFileContent = await File.ReadAllTextAsync(filePath);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error viewing file: {ex.Message}";
        }
    }

    private async Task GuessNames()
    {
        IsProcessing = true;
        ProgressPercentage = 0;
        StatusMessage = "Initializing name guessing process...";
        ErrorMessage = string.Empty;
        StateHasChanged();

        try
        {
            if (string.IsNullOrEmpty(_apiKey))
            {
                ErrorMessage = "API key is missing. Please check your configuration.";
                return;
            }

            if (string.IsNullOrEmpty(SelectedFolder))
            {
                ErrorMessage = "No folder selected. Please select a folder before guessing names.";
                return;
            }

            var folderPath = Path.Combine(WebHostEnvironment.WebRootPath, "uploads", SelectedFolder);
            if (!Directory.Exists(folderPath))
            {
                ErrorMessage = $"The selected folder '{SelectedFolder}' does not exist.";
                return;
            }

            var textFiles = Directory.GetFiles(folderPath, "*.txt");

            if (textFiles.Length == 0)
            {
                ErrorMessage = "No text files found in the selected folder.";
                return;
            }

            StatusMessage = "Reading file contents...";
            ProgressPercentage = 10;
            StateHasChanged();

            var fileContents = new List<string>();
            foreach (var file in textFiles)
            {
                try
                {
                    fileContents.Add(await File.ReadAllTextAsync(file));
                }
                catch (IOException ioEx)
                {
                    ErrorMessage = $"Error reading file {Path.GetFileName(file)}: {ioEx.Message}";
                    return;
                }
            }

            StatusMessage = "Preparing API request...";
            ProgressPercentage = 30;
            StateHasChanged();

            var prompt = @"Please analyze the conversations in the following files and assign names to the speakers. Use this template for your response:

[FILE_START:1]
Speaker A: [Name]
Speaker B: [Name]
...
[FILE_END:1]

[FILE_START:2]
Speaker A: [Name]
Speaker B: [Name]
...
[FILE_END:2]

... (continue for all files)

Important instructions:
1. Use only the names Jared, Lacey, Keri, Dave, Jeremiah, and Nikki.
2. Include only the speakers that appear in each file. Do not include entries for speakers not present.
3. The speaker designations (A, B, C, etc.) are specific to each file and do not need to be consistent across files. For example, Jared could be Speaker A in one file and Speaker C in another.
4. The number of files may vary. Provide assignments for each file present in the input.
5. If you're unsure about a speaker's identity, use your best judgment based on the conversation context.

Here are the file contents:

";

            for (int i = 0; i < fileContents.Count; i++)
            {
                prompt += $"File {i + 1} content:\n{fileContents[i]}\n\n";
            }

            prompt += "Please provide your analysis following the template above, adjusting for the actual number of files present.";

            var request = new
            {
                model = "chatgpt-4o-latest",
                messages = new[]
                {
                    new { role = "system", content = "You are an assistant that helps identify speakers in conversations." },
                    new { role = "user", content = prompt }
                }
            };

            StatusMessage = "Sending request to OpenAI API...";
            ProgressPercentage = 50;
            StateHasChanged();

            Http.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", _apiKey);
            HttpResponseMessage response;
            try
            {
                response = await Http.PostAsJsonAsync("https://api.openai.com/v1/chat/completions", request);
                StatusMessage = "Received response from OpenAI API...";
                ProgressPercentage = 60;
                StateHasChanged();
            }
            catch (HttpRequestException httpEx)
            {
                ErrorMessage = $"Error connecting to OpenAI API: {httpEx.Message}";
                return;
            }

            if (response.IsSuccessStatusCode)
            {
                StatusMessage = "Processing API response...";
                ProgressPercentage = 70;
                StateHasChanged();

                var responseBody = await response.Content.ReadAsStringAsync();

                try
                {
                    using (JsonDocument doc = JsonDocument.Parse(responseBody))
                    {
                        var root = doc.RootElement;
                        var choices = root.GetProperty("choices");
                        var messageContent = choices[0].GetProperty("message").GetProperty("content").GetString();

                        StatusMessage = "Applying guessed names to files...";
                        ProgressPercentage = 80;
                        StateHasChanged();

                        for (int i = 0; i < textFiles.Length; i++)
                        {
                            var fileContent = await File.ReadAllTextAsync(textFiles[i]);
                            var updatedContent = ApplyGuessedNames(fileContent, messageContent, i);
                            await File.WriteAllTextAsync(textFiles[i], updatedContent);

                            ProgressPercentage = 80 + (i + 1) * 20 / textFiles.Length;
                            StatusMessage = $"Updated file {i + 1} of {textFiles.Length}...";
                            StateHasChanged();
                        }
                    }

                    StatusMessage = "Names guessed and applied successfully.";
                    ProgressPercentage = 100;
                    StateHasChanged();

                    await LoadFolders();
                    await LoadFiles(SelectedFolder);
                }
                catch (JsonException jsonEx)
                {
                    ErrorMessage = $"Error parsing API response: {jsonEx.Message}";
                }
                catch (IOException ioEx)
                {
                    ErrorMessage = $"Error writing to files: {ioEx.Message}";
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                ErrorMessage = $"API request failed: {response.StatusCode} - {errorContent}";
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Unexpected error in GuessNames: {ex.Message}";
        }
        finally
        {
            IsProcessing = false;
            if (string.IsNullOrEmpty(ErrorMessage))
            {
                StatusMessage = "Process completed successfully.";
            }
            else
            {
                StatusMessage = "Process completed with errors.";
            }
            StateHasChanged();
        }
    }

    private string ApplyGuessedNames(string fileContent, string messageContent, int fileIndex)
    {
        try
        {
            var speakerMap = new Dictionary<string, string>();
            var filePattern = $@"\[FILE_START:{fileIndex + 1}\](.*?)\[FILE_END:{fileIndex + 1}\]";
            var match = Regex.Match(messageContent, filePattern, RegexOptions.Singleline);

            if (!match.Success)
            {
                ErrorMessage += $"\nNo speaker assignments found for file {fileIndex + 1}.";
                return fileContent;
            }

            var fileAssignments = match.Groups[1].Value.Trim();
            var lines = fileAssignments.Split('\n', StringSplitOptions.RemoveEmptyEntries);

            foreach (var line in lines)
            {
                var parts = line.Split(':', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length == 2)
                {
                    var speaker = parts[0].Trim();
                    var name = parts[1].Trim();
                    speakerMap[speaker] = name;
                }
            }

            if (speakerMap.Count == 0)
            {
                ErrorMessage += $"\nNo valid speaker mappings found for file {fileIndex + 1}.";
                return fileContent;
            }

            foreach (var speaker in speakerMap)
            {
                fileContent = Regex.Replace(fileContent, $@"{Regex.Escape(speaker.Key)}:", $"{speaker.Value}:", RegexOptions.IgnoreCase);
            }

            return fileContent;
        }
        catch (Exception ex)
        {
            ErrorMessage += $"\nError applying guessed names to file {fileIndex + 1}: {ex.Message}";
            return fileContent;
        }
    }
}