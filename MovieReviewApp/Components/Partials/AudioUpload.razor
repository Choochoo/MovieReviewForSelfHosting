@page "/discussions/upload"
@using System.Globalization
@using System.Security.Cryptography
@using AssemblyAI;
@using AssemblyAI.Transcripts;
@using System.Text
@using NAudio.Wave
@inject IWebHostEnvironment WebHostEnvironment
@inject IConfiguration Configuration
@inject IJSRuntime JSRuntime

<h4>Upload Audio Clips</h4>

<div class="form-group">
    <div class="input-group mb-3">
        @if (fileInputVisible)
        {
            <InputFile OnChange="HandleSelected" multiple class="form-control-file" />
        }
        <button @onclick="UploadFiles" class="btn btn-primary" disabled="@isUploadButtonDisabled">Upload</button>
    </div>
    @if (!string.IsNullOrEmpty(Error))
    {
        <div class="alert alert-danger" role="alert">
            @Error
        </div>
    }
    @if (!string.IsNullOrEmpty(SuccessMessage))
    {
        <div class="alert alert-success" role="alert">
            @SuccessMessage
        </div>
    }
    <div id="progressBarContainer" style="display: none;">
        <div class="progress">
            <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
        </div>
    </div>
</div>

<div class="form-group">
    <h4>Process Files</h4>
    <div class="input-group mb-3 flex-column flex-sm-row">
        <select @bind="SelectedMonth" class="form-control mb-2 mb-sm-0 mr-sm-2" style="width: auto;">
            @foreach (var month in Months)
            {
                <option value="@month">@month</option>
            }
        </select>

        <select @bind="SelectedYear" class="form-control mb-2 mb-sm-0 mr-sm-2" style="width: auto;">
            @foreach (var year in Years)
            {
                <option value="@year">@year</option>
            }
        </select>

        <input type="password" @bind="PIN" placeholder="Enter PIN" class="form-control mb-2 mb-sm-0 mr-sm-2" style="width: auto;" />
        <button @onclick="ProcessFiles" class="btn btn-primary" disabled="@Processing">Process</button>
    </div>
</div>

@code {
    private bool Processing = false;
    private bool isUploadButtonDisabled = true;
    private bool fileInputVisible = true;
    private string SelectedMonth { get; set; } = DateTime.Now.ToString("MMMM");
    private int SelectedYear { get; set; } = DateTime.Now.Year;
    private List<string> Months = CultureInfo.CurrentCulture.DateTimeFormat.MonthNames.Take(12).ToList();
    private List<int> Years = Enumerable.Range(DateTime.Now.Year - 20, 21).ToList();
    private List<IBrowserFile> selectedFiles = new List<IBrowserFile>();
    public string Error = string.Empty;
    public string SuccessMessage = string.Empty;
    private string PIN { get; set; } = "";
    private AssemblyAIClient client;

    protected override void OnInitialized()
    {
        var apiKey = Configuration["AssemblyAI:ApiKey"];
        client = new AssemblyAIClient(apiKey);
    }

    private void HandleSelected(InputFileChangeEventArgs e)
    {
        selectedFiles = e.GetMultipleFiles().ToList();
        isUploadButtonDisabled = !selectedFiles.Any();
    }

    private async Task UploadFiles()
    {
        const long maxFileSize = 2L * 1024 * 1024 * 1024; // 2 GB limit
        isUploadButtonDisabled = true;
        Error = string.Empty;
        SuccessMessage = string.Empty;

        await JSRuntime.InvokeVoidAsync("showProgressBar");

        long totalSize = selectedFiles.Sum(f => f.Size);
        long uploadedSize = 0;

        foreach (var file in selectedFiles)
        {
            if (file.Size > maxFileSize)
            {
                Error = "File size exceeds the 2 GB limit.";
                isUploadButtonDisabled = false;
                await JSRuntime.InvokeVoidAsync("hideProgressBar");
                return;
            }

            try
            {
                var uploadsFolder = Path.Combine(WebHostEnvironment.WebRootPath, "uploads");
                if (!Directory.Exists(uploadsFolder))
                {
                    Directory.CreateDirectory(uploadsFolder);
                }

                var fileName = $"{Guid.NewGuid()}{Path.GetExtension(file.Name)}";
                var filePath = Path.Combine(uploadsFolder, fileName);

                using (var stream = new FileStream(filePath, FileMode.Create))
                {
                    var buffer = new byte[4096];
                    int bytesRead;
                    long totalBytesRead = 0;
                    var fileStream = file.OpenReadStream(maxFileSize);

                    while ((bytesRead = await fileStream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                    {
                        await stream.WriteAsync(buffer, 0, bytesRead);
                        totalBytesRead += bytesRead;
                        uploadedSize += bytesRead;

                        double overallProgress = (double)uploadedSize / totalSize * 100;
                        await JSRuntime.InvokeVoidAsync("updateProgressBar", Math.Round(overallProgress, 2));
                    }
                }

                SuccessMessage = "File(s) uploaded successfully.";
            }
            catch (Exception ex)
            {
                Error = $"An error occurred while uploading the file: {ex.Message}";
                isUploadButtonDisabled = false;
                await JSRuntime.InvokeVoidAsync("hideProgressBar");
                return;
            }
        }

        selectedFiles.Clear();
        isUploadButtonDisabled = true;

        fileInputVisible = false;
        StateHasChanged();
        await Task.Delay(100);
        fileInputVisible = true;

        await JSRuntime.InvokeVoidAsync("hideProgressBar");
    }

    private async Task ProcessFiles()
    {
        const string correctPIN = "9021";
        if (PIN != correctPIN)
        {
            Error = "Invalid PIN.";
            return;
        }

        Processing = true;
        Error = "";
        SuccessMessage = "";

        try
        {
            var uploadsFolder = Path.Combine(WebHostEnvironment.WebRootPath, "uploads");
            var targetFolder = Path.Combine(uploadsFolder, $"{SelectedMonth}-{SelectedYear}");
            if (!Directory.Exists(targetFolder))
            {
                Directory.CreateDirectory(targetFolder);
            }

            // Delete duplicate files before processing
            await DeleteDuplicateFilesAsync(uploadsFolder);

            foreach (var file in Directory.GetFiles(uploadsFolder))
            {
                var fileInfo = new FileInfo(file);
                if (fileInfo.DirectoryName == targetFolder) continue;

                var duration = GetMediaDuration(file);
                var durationString = FormatDuration(duration);
                var newFileName = $"{SelectedMonth}-{SelectedYear}_{durationString}{fileInfo.Extension}";
                var destFileName = Path.Combine(targetFolder, newFileName);

                // Ensure the new filename is unique
                int counter = 1;
                while (File.Exists(destFileName))
                {
                    newFileName = $"{SelectedMonth}-{SelectedYear}_{durationString}_{counter}{fileInfo.Extension}";
                    destFileName = Path.Combine(targetFolder, newFileName);
                    counter++;
                }

                if (IsAudioFile(file))
                {
                    var transcript = await TranscribeAudioAsync(file);
                    if (!string.IsNullOrEmpty(transcript))
                    {
                        var transcriptFileName = Path.ChangeExtension(newFileName, ".txt");
                        var transcriptPath = Path.Combine(targetFolder, transcriptFileName);
                        await File.WriteAllTextAsync(transcriptPath, transcript);

                        // Move the audio file only after successful transcription
                        File.Move(fileInfo.FullName, destFileName);
                    }
                    else
                    {
                        // If transcription failed, log an error but don't move the file
                        Error += $"\nFailed to transcribe: {fileInfo.Name}";
                    }
                }
                else
                {
                    // For non-audio files, move them immediately
                    File.Move(fileInfo.FullName, destFileName);
                }
            }

            SuccessMessage = "Files processed successfully.";
        }
        catch (Exception ex)
        {
            Error = $"An error occurred while processing the files: {ex.Message}";
        }

        Processing = false;
    }

    private TimeSpan GetMediaDuration(string filePath)
    {
        try
        {
            using (var reader = new MediaFoundationReader(filePath))
            {
                return reader.TotalTime;
            }
        }
        catch
        {
            // If we can't determine the duration, return zero
            return TimeSpan.Zero;
        }
    }

    private string FormatDuration(TimeSpan duration)
    {
        if (duration.TotalHours >= 1)
        {
            return $"{(int)duration.TotalHours}hr_{duration.Minutes}min_{duration.Seconds}sec";
        }
        else
        {
            return $"{duration.Minutes}min_{duration.Seconds}sec";
        }
    }

    private async Task DeleteDuplicateFilesAsync(string folderPath)
    {
        var fileHashes = new Dictionary<string, string>();
        foreach (var file in Directory.GetFiles(folderPath))
        {
            var fileHash = await GetFileHashAsync(file);
            if (fileHashes.ContainsKey(fileHash))
            {
                // This is a duplicate file, delete it
                File.Delete(file);
            }
            else
            {
                fileHashes[fileHash] = file;
            }
        }
    }

    private async Task<string> GetFileHashAsync(string filePath)
    {
        using var md5 = MD5.Create();
        using var stream = File.OpenRead(filePath);
        var hash = await md5.ComputeHashAsync(stream);
        return BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
    }

    private bool IsAudioFile(string filePath)
    {
        var audioExtensions = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            // Common audio file extensions
            ".mp3", ".wav", ".ogg", ".flac", ".aac", ".m4a", ".wma",

            // Video file extensions that may contain audio
            ".mp4", ".mov", ".avi", ".mkv", ".webm",

            // Apple-specific formats
            ".m4v", ".3gp",

            // Additional formats
            ".aiff", ".ac3", ".amr"
        };

        return audioExtensions.Contains(Path.GetExtension(filePath));
    }

    private async Task<string> TranscribeAudioAsync(string filePath)
    {
        try
        {
            var uploadedFile = await client.Files.UploadAsync(new FileInfo(filePath));
            var transcriptParams = new AssemblyAI.Transcripts.TranscriptParams
                {
                    AudioUrl = uploadedFile.UploadUrl,
                    SpeakerLabels = true  // Enable speaker diarization
                };

            var transcript = await client.Transcripts.TranscribeAsync(transcriptParams);
            transcript.EnsureStatusCompleted();

            if (transcript.Status == AssemblyAI.Transcripts.TranscriptStatus.Completed)
            {
                return FormatTranscriptWithSpeakers(transcript);
            }
            else
            {
                Error += $"\nTranscription failed: {transcript.Status}";
                return null;
            }
        }
        catch (Exception ex)
        {
            Error += $"\nTranscription error: {ex.Message}";
            return null;
        }
    }

    private string FormatTranscriptWithSpeakers(AssemblyAI.Transcripts.Transcript transcript)
    {
        if (transcript.Utterances == null || !transcript.Utterances.Any())
        {
            return transcript.Text; // Return the full text if no utterances are available
        }

        var formattedTranscript = new StringBuilder();
        foreach (var utterance in transcript.Utterances)
        {
            formattedTranscript.AppendLine($"Speaker {utterance.Speaker}: {utterance.Text}");
        }
        return formattedTranscript.ToString();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                function showProgressBar() {
                    document.getElementById('progressBarContainer').style.display = 'block';
                }

                function hideProgressBar() {
                    document.getElementById('progressBarContainer').style.display = 'none';
                }

                function updateProgressBar(percentage) {
                    var progressBar = document.getElementById('progressBar');
                    progressBar.style.width = percentage + '%';
                    progressBar.setAttribute('aria-valuenow', percentage);
                    progressBar.textContent = percentage + '%';
                }

                window.showProgressBar = showProgressBar;
                window.hideProgressBar = hideProgressBar;
                window.updateProgressBar = updateProgressBar;
            ");
        }
    }
}