@page "/discussions/upload"
@using System.Globalization
@using System.Security.Cryptography
@using AssemblyAI;
@using AssemblyAI.Transcripts;
@using System.Text
@using NAudio.Wave
@inject IWebHostEnvironment WebHostEnvironment
@inject IConfiguration Configuration
@inject IJSRuntime JSRuntime

<h4>Upload Audio Clips</h4>

<div class="form-group">
    <div class="input-group mb-3">
        @if (fileInputVisible)
        {
            <InputFile OnChange="HandleSelected" multiple class="form-control-file" />
        }
        <button @onclick="UploadFiles" class="btn btn-primary" disabled="@isUploadButtonDisabled">Upload</button>
    </div>
    @if (!string.IsNullOrEmpty(Error))
    {
        <div class="alert alert-danger" role="alert">
            @Error
        </div>
    }
    @if (!string.IsNullOrEmpty(SuccessMessage))
    {
        <div class="alert alert-success" role="alert">
            @SuccessMessage
        </div>
    }
    <div id="progressBarContainer" style="display: none;">
        <div class="progress">
            <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
        </div>
    </div>
</div>

<div class="form-group">
    <h4>Process Files</h4>
    <div class="input-group mb-3 flex-column flex-sm-row">
        <select @bind="SelectedMonth" class="form-control mb-2 mb-sm-0 mr-sm-2" style="width: auto;">
            @foreach (var month in Months)
            {
                <option value="@month">@month</option>
            }
        </select>

        <select @bind="SelectedYear" class="form-control mb-2 mb-sm-0 mr-sm-2" style="width: auto;">
            @foreach (var year in Years)
            {
                <option value="@year">@year</option>
            }
        </select>

        <input type="password" @bind="PIN" placeholder="Enter PIN" class="form-control mb-2 mb-sm-0 mr-sm-2" style="width: auto;" />
        <button @onclick="ProcessFiles" class="btn btn-primary" disabled="@Processing">Process</button>
    </div>
    @if (!FoundApiKey)
    {
        <small class="text-danger">API key not found. Please add your AssemblyAI API key to the appsettings.json file.</small>
    }
    @if (CurrentException.Length > 0)
    {
        <div class="alert alert-danger" role="alert">
            Exception: @CurrentException
        </div>
    }
</div>

@code {
    private bool Processing = false;
    private bool isUploadButtonDisabled = true;
    private bool fileInputVisible = true;
    private string SelectedMonth { get; set; } = DateTime.Now.ToString("MMMM");
    private int SelectedYear { get; set; } = DateTime.Now.Year;
    private List<string> Months = CultureInfo.CurrentCulture.DateTimeFormat.MonthNames.Take(12).ToList();
    private List<int> Years = Enumerable.Range(DateTime.Now.Year - 20, 21).ToList();
    private List<IBrowserFile> selectedFiles = new List<IBrowserFile>();
    public string Error = string.Empty;
    public string SuccessMessage = string.Empty;
    private string PIN { get; set; } = "";
    private AssemblyAIClient client;
    private bool FoundApiKey = false;
    private string CurrentException = "";
    private int CurrentFileNumber { get; set; }
    private int TotalFiles { get; set; }
    private string CurrentFileName { get; set; }
    private int ProgressPercentage { get; set; }

    protected override void OnInitialized()
    {
        try
        {
            var apiKey = Configuration["AssemblyAI:ApiKey"];
            FoundApiKey = !string.IsNullOrEmpty(apiKey);
            client = new AssemblyAIClient(apiKey);
        }
        catch (Exception ex)
        {
            CurrentException = $"Error initializing: {ex.Message}";
        }
    }

    private void HandleSelected(InputFileChangeEventArgs e)
    {
        try
        {
            selectedFiles = e.GetMultipleFiles().ToList();
            isUploadButtonDisabled = !selectedFiles.Any();
        }
        catch (Exception ex)
        {
            CurrentException = $"Error selecting files: {ex.Message}";
        }
    }

    private async Task UploadFiles()
    {
        const long maxFileSize = 2L * 1024 * 1024 * 1024; // 2 GB limit
        isUploadButtonDisabled = true;
        Error = string.Empty;
        SuccessMessage = string.Empty;
        CurrentException = string.Empty;

        try
        {
            await JSRuntime.InvokeVoidAsync("showProgressBar");

            long totalSize = selectedFiles.Sum(f => f.Size);
            long uploadedSize = 0;

            foreach (var file in selectedFiles)
            {
                if (file.Size > maxFileSize)
                {
                    Error = "File size exceeds the 2 GB limit.";
                    isUploadButtonDisabled = false;
                    await JSRuntime.InvokeVoidAsync("hideProgressBar");
                    return;
                }

                try
                {
                    var uploadsFolder = Path.Combine(WebHostEnvironment.WebRootPath, "uploads");
                    if (!Directory.Exists(uploadsFolder))
                    {
                        Directory.CreateDirectory(uploadsFolder);
                    }

                    var fileName = $"{Guid.NewGuid()}{Path.GetExtension(file.Name)}";
                    var filePath = Path.Combine(uploadsFolder, fileName);

                    using (var stream = new FileStream(filePath, FileMode.Create))
                    {
                        var buffer = new byte[4096];
                        int bytesRead;
                        long totalBytesRead = 0;
                        var fileStream = file.OpenReadStream(maxFileSize);

                        while ((bytesRead = await fileStream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                        {
                            await stream.WriteAsync(buffer, 0, bytesRead);
                            totalBytesRead += bytesRead;
                            uploadedSize += bytesRead;

                            double overallProgress = (double)uploadedSize / totalSize * 100;
                            await JSRuntime.InvokeVoidAsync("updateProgressBar", Math.Round(overallProgress, 2));
                        }
                    }

                    SuccessMessage = "File(s) uploaded successfully.";
                }
                catch (Exception ex)
                {
                    Error += $"\nError uploading {file.Name}: {ex.Message}";
                    CurrentException += $"\nException while uploading {file.Name}: {ex}";
                }
            }
        }
        catch (Exception ex)
        {
            Error = "An error occurred during the upload process.";
            CurrentException = $"Upload process exception: {ex}";
        }
        finally
        {
            selectedFiles.Clear();
            isUploadButtonDisabled = true;
            fileInputVisible = false;
            StateHasChanged();
            await Task.Delay(100);
            fileInputVisible = true;
            await JSRuntime.InvokeVoidAsync("hideProgressBar");
        }
    }

    private async Task ProcessFiles()
    {
        const string correctPIN = "9021";
        if (PIN != correctPIN)
        {
            Error = "Invalid PIN.";
            return;
        }

        Processing = true;
        Error = "";
        SuccessMessage = "";
        CurrentException = "";

        try
        {
            var uploadsFolder = Path.Combine(WebHostEnvironment.WebRootPath, "uploads");
            var targetFolder = Path.Combine(uploadsFolder, $"{SelectedMonth}-{SelectedYear}");
            if (!Directory.Exists(targetFolder))
            {
                Directory.CreateDirectory(targetFolder);
            }

            await DeleteDuplicateFilesAsync(uploadsFolder);

            var files = Directory.GetFiles(uploadsFolder);
            TotalFiles = files.Length;
            CurrentFileNumber = 0;

            foreach (var file in files)
            {
                CurrentFileNumber++;
                CurrentFileName = Path.GetFileName(file);
                ProgressPercentage = (int)((float)CurrentFileNumber / TotalFiles * 100);
                StateHasChanged();
                try
                {
                    var fileInfo = new FileInfo(file);
                    if (fileInfo.DirectoryName == targetFolder) continue;

                    var duration = GetMediaDuration(file);
                    var durationString = FormatDuration(duration);
                    var newFileName = $"{SelectedMonth}-{SelectedYear}_{durationString}{fileInfo.Extension}";
                    var destFileName = Path.Combine(targetFolder, newFileName);

                    int counter = 1;
                    while (File.Exists(destFileName))
                    {
                        newFileName = $"{SelectedMonth}-{SelectedYear}_{durationString}_{counter}{fileInfo.Extension}";
                        destFileName = Path.Combine(targetFolder, newFileName);
                        counter++;
                    }

                    if (IsAudioFile(file))
                    {
                        var transcript = await TranscribeAudioAsync(file);
                        if (!string.IsNullOrEmpty(transcript))
                        {
                            var transcriptFileName = Path.ChangeExtension(newFileName, ".txt");
                            var transcriptPath = Path.Combine(targetFolder, transcriptFileName);
                            await File.WriteAllTextAsync(transcriptPath, transcript);
                            File.Move(fileInfo.FullName, destFileName);
                        }
                        else
                        {
                            Error += $"\nFailed to transcribe: {fileInfo.Name}";
                        }
                    }
                    else
                    {
                        File.Move(fileInfo.FullName, destFileName);
                    }
                }
                catch (Exception ex)
                {
                    Error += $"\nError processing file {Path.GetFileName(file)}: {ex.Message}";
                    CurrentException += $"\nException processing file {file}: {ex}";
                }

                await Task.Delay(100); // Small delay to allow UI update
            }

            SuccessMessage = "Files processed successfully.";
        }
        catch (Exception ex)
        {
            Error = "An error occurred while processing the files.";
            CurrentException = $"File processing exception: {ex}";
        }
        finally
        {
            Processing = false;
            CurrentFileNumber = 0;
            CurrentFileName = "";
            ProgressPercentage = 0;
        }
    }

    private string FormatDuration(TimeSpan duration)
    {
        if (duration.TotalHours >= 1)
        {
            return $"{(int)duration.TotalHours}hr_{duration.Minutes}min_{duration.Seconds}sec";
        }
        else
        {
            return $"{duration.Minutes}min_{duration.Seconds}sec";
        }
    }

    private bool IsAudioFile(string filePath)
    {
        var audioExtensions = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            // Common audio file extensions
            ".mp3", ".wav", ".ogg", ".flac", ".aac", ".m4a", ".wma",

            // Video file extensions that may contain audio
            ".mp4", ".mov", ".avi", ".mkv", ".webm",

            // Apple-specific formats
            ".m4v", ".3gp",

            // Additional formats
            ".aiff", ".ac3", ".amr"
        };

        return audioExtensions.Contains(Path.GetExtension(filePath));
    }

    private TimeSpan GetMediaDuration(string filePath)
    {
        try
        {
            using (var reader = new MediaFoundationReader(filePath))
            {
                return reader.TotalTime;
            }
        }
        catch (Exception ex)
        {
            CurrentException += $"\nError getting media duration for {Path.GetFileName(filePath)}: {ex}";
            return TimeSpan.Zero;
        }
    }

    private async Task DeleteDuplicateFilesAsync(string folderPath)
    {
        try
        {
            var fileHashes = new Dictionary<string, string>();
            foreach (var file in Directory.GetFiles(folderPath))
            {
                try
                {
                    var fileHash = await GetFileHashAsync(file);
                    if (fileHashes.ContainsKey(fileHash))
                    {
                        File.Delete(file);
                    }
                    else
                    {
                        fileHashes[fileHash] = file;
                    }
                }
                catch (Exception ex)
                {
                    CurrentException += $"\nError processing file for duplication {Path.GetFileName(file)}: {ex}";
                }
            }
        }
        catch (Exception ex)
        {
            CurrentException += $"\nError in duplicate file deletion process: {ex}";
        }
    }

    private async Task<string> GetFileHashAsync(string filePath)
    {
        try
        {
            using var md5 = MD5.Create();
            using var stream = File.OpenRead(filePath);
            var hash = await md5.ComputeHashAsync(stream);
            return BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
        }
        catch (Exception ex)
        {
            CurrentException += $"\nError calculating hash for {Path.GetFileName(filePath)}: {ex}";
            return string.Empty;
        }
    }

    private async Task<string> TranscribeAudioAsync(string filePath)
    {
        try
        {
            var uploadedFile = await client.Files.UploadAsync(new FileInfo(filePath));
            var transcriptParams = new AssemblyAI.Transcripts.TranscriptParams
                {
                    AudioUrl = uploadedFile.UploadUrl,
                    SpeakerLabels = true
                };

            var transcript = await client.Transcripts.TranscribeAsync(transcriptParams);
            transcript.EnsureStatusCompleted();

            if (transcript.Status == AssemblyAI.Transcripts.TranscriptStatus.Completed)
            {
                return FormatTranscriptWithSpeakers(transcript);
            }
            else
            {
                Error += $"\nTranscription failed: {transcript.Status}";
                return null;
            }
        }
        catch (Exception ex)
        {
            Error += $"\nTranscription error for {Path.GetFileName(filePath)}: {ex.Message}";
            CurrentException += $"\nTranscription exception for {filePath}: {ex}";
            return null;
        }
    }

    private string FormatTranscriptWithSpeakers(AssemblyAI.Transcripts.Transcript transcript)
    {
        if (transcript.Utterances == null || !transcript.Utterances.Any())
        {
            return transcript.Text; // Return the full text if no utterances are available
        }

        var formattedTranscript = new StringBuilder();
        foreach (var utterance in transcript.Utterances)
        {
            formattedTranscript.AppendLine($"Speaker {utterance.Speaker}: {utterance.Text}");
        }
        return formattedTranscript.ToString();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                function showProgressBar() {
                    document.getElementById('progressBarContainer').style.display = 'block';
                }

                function hideProgressBar() {
                    document.getElementById('progressBarContainer').style.display = 'none';
                }

                function updateProgressBar(percentage) {
                    var progressBar = document.getElementById('progressBar');
                    progressBar.style.width = percentage + '%';
                    progressBar.setAttribute('aria-valuenow', percentage);
                    progressBar.textContent = percentage + '%';
                }

                window.showProgressBar = showProgressBar;
                window.hideProgressBar = hideProgressBar;
                window.updateProgressBar = updateProgressBar;
            ");
        }
    }
}